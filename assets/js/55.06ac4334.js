(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{391:function(s,a,e){"use strict";e.r(a);var t=e(2),v=Object(t.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"搭建主从架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#搭建主从架构"}},[s._v("#")]),s._v(" 搭建主从架构")]),s._v(" "),a("p",[s._v("单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。")]),s._v(" "),a("p",[a("strong",[s._v("默认是 主节点进行读写操作，从节点是只读操作")])]),s._v(" "),a("p",[a("img",{attrs:{src:"/assets/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/image-20210725152037611.png",alt:"image-20210725152037611"}})]),s._v(" "),a("p",[a("RouterLink",{attrs:{to:"/pages/564491/"}},[s._v("具体搭建流程")])],1),s._v(" "),a("p",[s._v("基本命令")]),s._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 连接 7002")]),s._v("\nredis-cli "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[s._v("-p")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("7002")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 执行slaveof")]),s._v("\nslaveof "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("192.168")]),s._v(".150.101 "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("7001")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 连接 7003")]),s._v("\nredis-cli "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[s._v("-p")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("7003")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 执行slaveof")]),s._v("\nslaveof "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("192.168")]),s._v(".150.101 "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("7001")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#修改配置文件-conf ————bind 0.0.0.0")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 连接 7001")]),s._v("\nredis-cli "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[s._v("-p")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("7001")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 查看状态")]),s._v("\ninfo replication\n")])])]),a("h2",{attrs:{id:"主从数据同步原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主从数据同步原理"}},[s._v("#")]),s._v(" 主从数据同步原理")]),s._v(" "),a("h3",{attrs:{id:"全量同步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#全量同步"}},[s._v("#")]),s._v(" 全量同步")]),s._v(" "),a("p",[s._v("主从第一次建立连接时，会执行"),a("strong",[s._v("全量同步")]),s._v("，将master节点的所有数据都拷贝给slave节点，流程：")]),s._v(" "),a("p",[a("img",{attrs:{src:"/assets/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/image-20210725152222497.png",alt:"image-20210725152222497"}})]),s._v(" "),a("p",[s._v("这里有一个问题，master如何得知salve是第一次来连接呢？？")]),s._v(" "),a("p",[s._v("有几个概念，可以作为判断依据：")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("Replication Id")]),s._v("：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid")]),s._v(" "),a("li",[a("strong",[s._v("offset")]),s._v("：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。")])]),s._v(" "),a("p",[s._v("因此slave做数据同步，必须向master声明自己的replication id 和offset，master才可以判断到底需要同步哪些数据。")]),s._v(" "),a("p",[s._v("因为slave原本也是一个master，有自己的replid和offset，当第一次变成slave，与master建立连接时，发送的replid和offset是自己的replid和offset。")]),s._v(" "),a("p",[s._v("master判断发现slave发送来的replid与自己的不一致，说明这是一个全新的slave，就知道要做全量同步了。")]),s._v(" "),a("p",[s._v("master会将自己的replid和offset都发送给这个slave，slave保存这些信息。以后slave的replid就与master一致了。")]),s._v(" "),a("p",[s._v("因此，"),a("strong",[s._v("master判断一个节点是否是第一次同步的依据，就是看replid是否一致")]),s._v("。")]),s._v(" "),a("p",[s._v("如图：")]),s._v(" "),a("p",[a("img",{attrs:{src:"/assets/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/image-20210725152700914.png",alt:"image-20210725152700914"}})]),s._v(" "),a("p",[s._v("完整流程描述：")]),s._v(" "),a("ul",[a("li",[s._v("slave节点请求增量同步")]),s._v(" "),a("li",[s._v("master节点判断replid，发现不一致，拒绝增量同步")]),s._v(" "),a("li",[s._v("master将完整内存数据生成RDB，发送RDB到slave")]),s._v(" "),a("li",[s._v("slave清空本地数据，加载master的RDB")]),s._v(" "),a("li",[s._v("master将RDB期间的命令记录在repl_baklog，并持续将log中的命令发送给slave")]),s._v(" "),a("li",[s._v("slave执行接收到的命令，保持与master之间的同步")])]),s._v(" "),a("ul",[a("li",[s._v("从节点日志")])]),s._v(" "),a("p",[a("img",{attrs:{src:"/assets/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E4%BB%8E%E8%8A%82%E7%82%B9%E9%93%BE%E6%8E%A5%E6%97%A5%E5%BF%97.png",alt:""}})]),s._v(" "),a("ul",[a("li",[s._v("主节点日志")])]),s._v(" "),a("p",[a("img",{attrs:{src:"/assets/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E4%B8%BB%E8%8A%82%E7%82%B9%E9%93%BE%E6%8E%A5%E6%97%A5%E5%BF%97.png",alt:"主节点链接日志"}})]),s._v(" "),a("h3",{attrs:{id:"增量同步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#增量同步"}},[s._v("#")]),s._v(" 增量同步")]),s._v(" "),a("p",[s._v("全量同步需要先做RDB，然后将RDB文件通过网络传输个slave，成本太高了。因此除了第一次做全量同步，其它大多数时候slave与master都是做"),a("strong",[s._v("增量同步")]),s._v("。")]),s._v(" "),a("ul",[a("li",[s._v("例如 slave 重启后，则执行增量同步")])]),s._v(" "),a("p",[s._v("什么是增量同步？就是只更新slave与master存在差异的部分数据。如图：")]),s._v(" "),a("p",[a("img",{attrs:{src:"/assets/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/image-20210725153201086.png",alt:"image-20210725153201086"}})]),s._v(" "),a("p",[s._v("那么master怎么知道slave与自己的数据差异在哪里呢?")]),s._v(" "),a("h3",{attrs:{id:"repl-backlog原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#repl-backlog原理"}},[s._v("#")]),s._v(" repl_backlog原理")]),s._v(" "),a("p",[s._v("master怎么知道slave与自己的数据差异在哪里呢?")]),s._v(" "),a("p",[s._v("这就要说到全量同步时的repl_baklog文件了。")]),s._v(" "),a("p",[s._v("这个文件是一个固定大小的数组，只不过数组是环形，也就是说"),a("strong",[s._v("角标到达数组末尾后，会再次从0开始读写")]),s._v("，这样数组头部的数据就会被覆盖。")]),s._v(" "),a("p",[s._v("repl_baklog中会记录Redis处理过的命令日志及offset，包括master当前的offset，和slave已经拷贝到的offset：")]),s._v(" "),a("p",[a("img",{attrs:{src:"/assets/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/image-20210725153359022.png",alt:"image-20210725153359022"}})]),s._v(" "),a("p",[s._v("slave与master的offset之间的差异，就是salve需要增量拷贝的数据了。")]),s._v(" "),a("p",[s._v("随着不断有数据写入，master的offset逐渐变大，slave也不断的拷贝，追赶master的offset：")]),s._v(" "),a("p",[a("img",{attrs:{src:"/assets/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/image-20210725153524190.png",alt:"image-20210725153524190"}})]),s._v(" "),a("p",[s._v("直到数组被填满：")]),s._v(" "),a("p",[a("img",{attrs:{src:"/assets/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/image-20210725153715910.png",alt:"image-20210725153715910"}})]),s._v(" "),a("p",[s._v("此时，如果有新的数据写入，就会覆盖数组中的旧数据。不过，旧的数据只要是绿色的，说明是已经被同步到slave的数据，即便被覆盖了也没什么影响。因为未同步的仅仅是红色部分。")]),s._v(" "),a("p",[s._v("但是，如果slave出现网络阻塞，导致master的offset远远超过了slave的offset：")]),s._v(" "),a("p",[a("img",{attrs:{src:"/assets/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/image-20210725153937031.png",alt:"image-20210725153937031"}})]),s._v(" "),a("p",[s._v("如果master继续写入新数据，其offset就会覆盖旧的数据，直到将slave现在的offset也覆盖：")]),s._v(" "),a("p",[a("img",{attrs:{src:"/assets/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/image-20210725154155984.png",alt:"image-20210725154155984"}})]),s._v(" "),a("p",[a("strong",[s._v("棕色框中的红色部分，就是尚未同步，但是却已经被覆盖的数据。此时如果slave恢复，需要同步，却发现自己的offset都没有了，无法完成增量同步了。只能做全量同步。")])]),s._v(" "),a("p",[a("img",{attrs:{src:"/assets/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/image-20210725154216392.png",alt:"image-20210725154216392"}})]),s._v(" "),a("h2",{attrs:{id:"主从同步优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主从同步优化"}},[s._v("#")]),s._v(" 主从同步优化")]),s._v(" "),a("p",[s._v("主从同步可以保证主从数据的一致性，非常重要。")]),s._v(" "),a("p",[s._v("可以从以下几个方面来优化Redis主从就集群：")]),s._v(" "),a("ul",[a("li",[s._v("在master中配置"),a("code",[s._v("repl-diskless-sync yes")]),s._v("启用无磁盘复制，避免全量同步时的磁盘IO。")]),s._v(" "),a("li",[s._v("Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO")]),s._v(" "),a("li",[s._v("适当提高repl_baklog的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步")]),s._v(" "),a("li",[s._v("限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力")])]),s._v(" "),a("p",[s._v("主从从架构图：")]),s._v(" "),a("p",[a("img",{attrs:{src:"/assets/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/image-20210725154405899.png",alt:"image-20210725154405899"}})]),s._v(" "),a("h2",{attrs:{id:"小结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[s._v("#")]),s._v(" 小结")]),s._v(" "),a("p",[s._v("简述全量同步和增量同步区别？")]),s._v(" "),a("ul",[a("li",[s._v("全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。")]),s._v(" "),a("li",[s._v("增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave")])]),s._v(" "),a("p",[s._v("什么时候执行全量同步？")]),s._v(" "),a("ul",[a("li",[s._v("slave节点第一次连接master节点时")]),s._v(" "),a("li",[s._v("slave节点断开时间太久，repl_baklog中的offset已经被覆盖时")])]),s._v(" "),a("p",[s._v("什么时候执行增量同步？")]),s._v(" "),a("ul",[a("li",[s._v("slave节点断开又恢复，并且在repl_baklog中能找到offset时")])])])}),[],!1,null,null,null);a.default=v.exports}}]);
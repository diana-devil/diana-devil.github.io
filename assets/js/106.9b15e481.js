(window.webpackJsonp=window.webpackJsonp||[]).push([[106],{440:function(v,t,_){"use strict";_.r(t);var a=_(2),s=Object(a.a)({},(function(){var v=this,t=v._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[v._v("解决分布式事务问题，需要一些分布式系统的基础知识作为理论指导。")]),v._v(" "),t("h2",{attrs:{id:"cap定理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cap定理"}},[v._v("#")]),v._v(" CAP定理")]),v._v(" "),t("p",[v._v("1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标。")]),v._v(" "),t("blockquote",[t("ul",[t("li",[v._v("Consistency（一致性）")]),v._v(" "),t("li",[v._v("Availability（可用性）")]),v._v(" "),t("li",[v._v("Partition tolerance （分区容错性）")])])]),v._v(" "),t("p",[t("img",{attrs:{src:"/assets/%E5%90%8E%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E8%BF%9B%E9%98%B6/image-20210724170517944.png",alt:"image-20210724170517944"}})]),v._v(" "),t("p",[v._v("它们的第一个字母分别是 C、A、P。")]),v._v(" "),t("p",[v._v("Eric Brewer 说，这三个指标不可能同时做到。这个结论就叫做 CAP 定理。")]),v._v(" "),t("h3",{attrs:{id:"一致性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一致性"}},[v._v("#")]),v._v(" 一致性")]),v._v(" "),t("p",[v._v("Consistency（一致性）："),t("strong",[v._v("用户访问分布式系统中的任意节点，得到的数据必须一致")]),v._v("。")]),v._v(" "),t("p",[v._v("比如现在包含两个节点，其中的初始数据是一致的：")]),v._v(" "),t("p",[t("img",{attrs:{src:"/assets/%E5%90%8E%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E8%BF%9B%E9%98%B6/image-20210724170704694.png",alt:"image-20210724170704694"}})]),v._v(" "),t("p",[v._v("当我们修改其中一个节点的数据时，两者的数据产生了差异：")]),v._v(" "),t("p",[t("img",{attrs:{src:"/assets/%E5%90%8E%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E8%BF%9B%E9%98%B6/image-20210724170735847.png",alt:"image-20210724170735847"}})]),v._v(" "),t("p",[v._v("要想保住一致性，就必须实现node01 到 node02的数据 同步：")]),v._v(" "),t("p",[t("img",{attrs:{src:"/assets/%E5%90%8E%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E8%BF%9B%E9%98%B6/image-20210724170834855.png",alt:"image-20210724170834855"}})]),v._v(" "),t("h3",{attrs:{id:"可用性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可用性"}},[v._v("#")]),v._v(" 可用性")]),v._v(" "),t("p",[v._v("Availability （可用性）："),t("strong",[v._v("用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝")]),v._v("。")]),v._v(" "),t("p",[v._v("如图，有三个节点的集群，访问任何一个都可以及时得到响应：")]),v._v(" "),t("p",[t("img",{attrs:{src:"/assets/%E5%90%8E%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E8%BF%9B%E9%98%B6/image-20210724170932072.png",alt:"image-20210724170932072"}})]),v._v(" "),t("p",[v._v("当有部分节点因为网络故障或其它原因无法访问时，代表节点不可用：")]),v._v(" "),t("p",[t("img",{attrs:{src:"/assets/%E5%90%8E%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E8%BF%9B%E9%98%B6/image-20210724171007516.png",alt:"image-20210724171007516"}})]),v._v(" "),t("h3",{attrs:{id:"分区容错"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分区容错"}},[v._v("#")]),v._v(" 分区容错")]),v._v(" "),t("p",[t("strong",[v._v("Partition（分区）")]),v._v("："),t("strong",[v._v("因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区")]),v._v("。")]),v._v(" "),t("p",[t("img",{attrs:{src:"/assets/%E5%90%8E%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E8%BF%9B%E9%98%B6/image-20210724171041210.png",alt:"image-20210724171041210"}})]),v._v(" "),t("p",[t("strong",[v._v("Tolerance（容错）")]),v._v("："),t("strong",[v._v("在集群出现分区时，整个系统也要持续对外提供服务")])]),v._v(" "),t("h3",{attrs:{id:"矛盾"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#矛盾"}},[v._v("#")]),v._v(" 矛盾")]),v._v(" "),t("p",[v._v("在分布式系统中，系统间的网络不能100%保证健康，一定会有故障的时候，而服务有必须对外保证服务。因此Partition Tolerance不可避免。")]),v._v(" "),t("p",[v._v("当节点接收到新的数据变更时，就会出现问题了：")]),v._v(" "),t("p",[t("img",{attrs:{src:"/assets/%E5%90%8E%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E8%BF%9B%E9%98%B6/image-20210724171546472.png",alt:"image-20210724171546472"}})]),v._v(" "),t("p",[v._v("如果此时要保证"),t("strong",[v._v("一致性-C")]),v._v("，就必须等待网络恢复，完成数据同步后，整个集群才对外提供服务，服务处于阻塞状态，不可用。")]),v._v(" "),t("p",[v._v("如果此时要保证"),t("strong",[v._v("可用性-A")]),v._v("，就不能等待网络恢复，那node01、node02与node03之间就会出现数据不一致。")]),v._v(" "),t("p",[v._v("也就是说，在P一定会出现的情况下，A和C之间只能实现一个。")]),v._v(" "),t("p",[t("strong",[v._v("思考")])]),v._v(" "),t("p",[t("code",[v._v("elasticsearch")]),v._v("集群是CP还是AP？——CP")]),v._v(" "),t("ul",[t("li",[v._v("ES集群出现问题时，会剔除故障节点，数据分片会重新分配到其他节点，保证"),t("strong",[v._v("数据一致性")])]),v._v(" "),t("li",[v._v("因此是低可用性，高一致性。——CP")])]),v._v(" "),t("h2",{attrs:{id:"base理论"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#base理论"}},[v._v("#")]),v._v(" BASE理论")]),v._v(" "),t("p",[v._v("BASE理论是对CAP的一种解决思路，包含三个思想：")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("Basically Available")]),v._v(" "),t("strong",[v._v("（基本可用）")]),v._v("：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。")]),v._v(" "),t("li",[t("strong",[v._v("Soft State（软状态）："),t("strong",[v._v("在一定时间内，允许出现中间状态，比如")]),v._v("临时")]),v._v("的不一致状态。")]),v._v(" "),t("li",[t("strong",[v._v("Eventually Consistent（最终一致性）")]),v._v("：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。")])]),v._v(" "),t("h2",{attrs:{id:"解决分布式事务的思路"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决分布式事务的思路"}},[v._v("#")]),v._v(" 解决分布式事务的思路")]),v._v(" "),t("p",[v._v("分布式事务最大的问题是各个子事务的一致性问题，因此可以借鉴CAP定理和BASE理论，有两种解决思路：")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("最终一致思想")]),v._v(" "),t("ul",[t("li",[v._v("AP模式：各子事务分别执行和提交，允许出现结果不一致，然后采用弥补措施恢复数据即可，"),t("strong",[v._v("实现最终一致。")])])])]),v._v(" "),t("li",[t("p",[v._v("强一致思想")]),v._v(" "),t("ul",[t("li",[v._v("CP模式：各个子事务执行后互相等待，"),t("strong",[v._v("同时提交，同时回滚，达成强一致")]),v._v("。但事务等待过程中，处于弱可用状态。")])])])]),v._v(" "),t("p",[v._v("但不管是哪一种模式，都需要在子系统事务之间互相通讯，协调事务状态，也就是需要一个"),t("strong",[v._v("事务协调者(TC)")]),v._v("：")]),v._v(" "),t("p",[t("img",{attrs:{src:"/assets/%E5%90%8E%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E8%BF%9B%E9%98%B6/image-20210724172123567.png",alt:"image-20210724172123567"}})]),v._v(" "),t("p",[v._v("这里的子系统事务，称为"),t("strong",[v._v("分支事务")]),v._v("；")]),v._v(" "),t("p",[v._v("有关联的各个分支事务在一起称为"),t("strong",[v._v("全局事务")]),v._v("。")])])}),[],!1,null,null,null);t.default=s.exports}}]);
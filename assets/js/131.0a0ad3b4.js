(window.webpackJsonp=window.webpackJsonp||[]).push([[131],{469:function(t,s,a){"use strict";a.r(s);var n=a(2),v=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"回溯算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#回溯算法"}},[t._v("#")]),t._v(" 回溯算法")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("定义")]),t._v(" "),s("blockquote",[s("p",[t._v("​\t回溯法也可以叫做回溯搜索法，它是一种搜索的方式。回溯是递归的副产品，只要有递归就会有回溯。")]),t._v(" "),s("p",[t._v("​\t所以以下讲解中，回溯函数也就是递归函数，指的都是一个函数。")])])]),t._v(" "),s("li",[s("p",[t._v("效率")]),t._v(" "),s("blockquote",[s("p",[t._v("**\t虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法**。")]),t._v(" "),s("p",[t._v("​\t"),s("strong",[t._v("因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案")]),t._v("，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。")])]),t._v(" "),s("ul",[s("li",[s("p",[t._v("效率不高为什么用？")]),t._v(" "),s("blockquote",[s("p",[s("strong",[t._v("因为没得选")]),t._v("，一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。")])])])])]),t._v(" "),s("li",[s("p",[t._v("解决问题")]),t._v(" "),s("ul",[s("li",[t._v("组合问题：N个数里面按一定规则找出k个数的集合")]),t._v(" "),s("li",[t._v("切割问题：一个字符串按一定规则有几种切割方式")]),t._v(" "),s("li",[t._v("子集问题：一个N个数的集合里有多少符合条件的子集")]),t._v(" "),s("li",[t._v("排列问题：N个数按一定规则全排列，有几种排列方式")]),t._v(" "),s("li",[t._v("棋盘问题：N皇后，解数独等等")])])]),t._v(" "),s("li",[s("p",[t._v("如何理解回溯法")]),t._v(" "),s("p",[s("strong",[t._v("回溯法解决的问题都可以抽象为树形结构")])]),t._v(" "),s("blockquote",[s("p",[t._v("因为回溯法解决的都是在集合中递归查找子集，"),s("strong",[t._v("集合的大小就构成了树的宽度，递归的深度，都构成的树的深度")]),t._v("。")]),t._v(" "),s("p",[t._v("递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。")])])]),t._v(" "),s("li",[s("p",[t._v("回溯法模板")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("回溯函数模板返回值以及参数")]),t._v(" "),s("ul",[s("li",[t._v("返回值一般为void，更新一个全局变量")]),t._v(" "),s("li",[t._v("参数不好确定，一般是先写逻辑，然后需要什么参数，就填什么参数。")])])]),t._v(" "),s("li",[s("p",[t._v("回溯函数终止条件")]),t._v(" "),s("ul",[s("li",[t._v("对树来说就是叶子结点")]),t._v(" "),s("li",[t._v("一般来说，就是找到了满足要求的一种情况，就可以保存答案，并结束递归")])])]),t._v(" "),s("li",[s("p",[t._v("回溯搜索的遍历过程")]),t._v(" "),s("ul",[s("li",[s("p",[s("strong",[t._v("回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。")])])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历")])]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("选择：本层集合中元素（树中节点孩子的数量就是集合的大小）"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    处理节点"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("backtracking")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("路径，选择列表"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 递归,自己调用自己")]),t._v("\n    回溯，撤销处理结果\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[s("img",{attrs:{src:"/assets/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%A8%A1%E6%9D%BF.png",alt:""}})])])])]),t._v(" "),s("li",[s("p",[t._v("回溯算法模板框架")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("backtracking")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("参数"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("终止条件"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        存放结果"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("选择：本层集合中元素（树中节点孩子的数量就是集合的大小）"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        处理节点"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("backtracking")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("路径，选择列表"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 递归")]),t._v("\n        回溯，撤销处理结果\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])])])])])])}),[],!1,null,null,null);s.default=v.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[126],{464:function(_,v,t){"use strict";t.r(v);var o=t(2),l=Object(o.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"遍历"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#遍历"}},[_._v("#")]),_._v(" 遍历")]),_._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"/assets/算法/前序遍历.png"}}),_._v(" "),v("ul",[v("li",[v("p",[_._v("前序遍历——中，左，右")]),_._v(" "),v("p",[v("code",[_._v("ABDGHCEIF")])])]),_._v(" "),v("li",[v("p",[_._v("中序遍历——左，中，右")]),_._v(" "),v("p",[v("code",[_._v("GDHBAEICF")])])]),_._v(" "),v("li",[v("p",[_._v("后序遍历——左，右，中")]),_._v(" "),v("p",[v("code",[_._v("GHDBIEFCA")])])]),_._v(" "),v("li",[v("p",[_._v("层序遍历")]),_._v(" "),v("p",[v("code",[_._v("ABCDEFGHI")])])])]),_._v(" "),v("h2",{attrs:{id:"完全二叉树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#完全二叉树"}},[_._v("#")]),_._v(" 完全二叉树")]),_._v(" "),v("ul",[v("li",[v("p",[v("strong",[_._v("具有n个结点的完全二叉树的深度为 $\\left \\lfloor log_2(n)+1 \\right \\rfloor $")])])]),_._v(" "),v("li",[v("p",[_._v("数组存储")]),_._v(" "),v("ul",[v("li",[_._v("一般的树存储用链表居多，完全二叉树当然也可以用链表存储。")]),_._v(" "),v("li",[_._v("但是由于完全二叉树的性质，用数组存储，更方便，也更节省空间。")])]),_._v(" "),v("p",[v("img",{attrs:{src:"/assets/%E7%AE%97%E6%B3%95/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8.webp",alt:""}})])]),_._v(" "),v("li",[v("p",[_._v("编号")]),_._v(" "),v("ul",[v("li",[_._v("若 "),v("code",[_._v("i=1")]),_._v(",则结点i为根结点，若"),v("code",[_._v("i>1")]),_._v("，则其双亲结点是$ \\left \\lfloor i/2 \\right \\rfloor$")]),_._v(" "),v("li",[_._v("如果"),v("code",[_._v("2i>n")]),_._v(",则结点i无左孩子，否则，其左孩子是结点"),v("code",[_._v("2i")])]),_._v(" "),v("li",[_._v("如果"),v("code",[_._v("2i+1>n")]),_._v(",则结点i无右孩子，否则，其右孩子是结点"),v("code",[_._v("2i+1")])])])])]),_._v(" "),v("h2",{attrs:{id:"二叉查找树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二叉查找树"}},[_._v("#")]),_._v(" 二叉查找树")]),_._v(" "),v("blockquote",[v("p",[_._v("​\t二叉查找树最大的特点就是，支持动态数据集合的快速插入、删除、查找操作。")])]),_._v(" "),v("ul",[v("li",[v("p",[_._v("要求")]),_._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"/assets/算法/二叉查找树.webp"}}),_._v(" "),v("blockquote",[v("p",[_._v("​\t二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。")])])]),_._v(" "),v("li",[v("p",[_._v("插入、删除、查找")]),_._v(" "),v("p",[_._v("==略==")])]),_._v(" "),v("li",[v("p",[_._v("支持重复数据的二叉查找树")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("同值扩容法")]),_._v(" "),v("blockquote",[v("p",[_._v("​\t二叉查找树中每一个节点不仅会存储一个数据，"),v("strong",[_._v("因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。")])])])]),_._v(" "),v("li",[v("p",[_._v("相同取大法")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("插入")]),_._v(" "),v("blockquote",[v("p",[_._v("​\t"),v("strong",[_._v("每个节点仍然只存储一个数据")]),_._v("。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，"),v("strong",[_._v("我们就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。")])]),_._v(" "),v("p",[v("img",{attrs:{src:"/assets/%E7%AE%97%E6%B3%95/%E6%8F%92%E5%85%A5%E7%9B%B8%E5%90%8C%E7%BB%93%E7%82%B9.webp",alt:""}})])])]),_._v(" "),v("li",[v("p",[_._v("查找")]),_._v(" "),v("blockquote",[v("p",[_._v("​\t当要查找数据的时候，"),v("strong",[_._v("遇到值相同的节点，我们并不停止查找操作")]),_._v("，"),v("strong",[_._v("而是继续在右子树中查找，直到遇到叶子节点，才停止")]),_._v("。这样就可以把键值等于要查找值的所有节点都找出来。")]),_._v(" "),v("p",[v("img",{attrs:{src:"/assets/%E7%AE%97%E6%B3%95/%E7%9B%B8%E5%90%8C%E7%BB%93%E7%82%B9%E6%9F%A5%E6%89%BE.webp",alt:""}})])])]),_._v(" "),v("li",[v("p",[_._v("删除")]),_._v(" "),v("blockquote",[v("p",[_._v("​\t对于删除操作，我们也需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除。")]),_._v(" "),v("p",[v("img",{attrs:{src:"/assets/%E7%AE%97%E6%B3%95/%E7%9B%B8%E5%90%8C%E7%BB%93%E7%82%B9%E5%88%A0%E9%99%A4.webp",alt:""}})])])])])])])]),_._v(" "),v("li",[v("p",[_._v("与散列表的对比")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("二叉查找树的劣势")]),_._v(" "),v("blockquote",[v("p",[_._v("​\t"),v("strong",[_._v("散列表的插入、删除、查找操作的时间复杂度可以做到常量级的 O(1)")]),_._v("，非常高效。")]),_._v(" "),v("p",[_._v("而"),v("strong",[_._v("二叉查找树在比较平衡的情况下")]),_._v("，插入、删除、查找操作时间复杂度才是 "),v("strong",[_._v("O(logn)")]),_._v("。")])])]),_._v(" "),v("li",[v("p",[_._v("二叉查找树的优势")]),_._v(" "),v("blockquote",[v("ol",[v("li",[v("p",[v("strong",[_._v("散列表中的数据是无序存储的")]),_._v("，如果要输出有序的数据，需要先进行排序。")]),_._v(" "),v("p",[_._v("而对于"),v("strong",[_._v("二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列。")])])]),_._v(" "),v("li",[v("p",[_._v("散列表扩容耗时很多，而且当遇到散列冲突时，"),v("strong",[_._v("性能不稳定")]),_._v("。")]),_._v(" "),v("p",[_._v("但是在工程中，我们最常用的"),v("strong",[_._v("平衡二叉查找树")]),_._v("的性能非常稳定，时间复杂度稳定在 "),v("strong",[_._v("O(logn)")]),_._v("。")])]),_._v(" "),v("li",[v("p",[_._v("笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，**但因为哈希冲突的存在，这个常量不一定比 logn 小，**所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。")])]),_._v(" "),v("li",[v("p",[_._v("**散列表的构造比二叉查找树要复杂，需要考虑的东西很多。**比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。")])]),_._v(" "),v("li",[v("p",[_._v("为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。")])])])])])])])]),_._v(" "),v("h2",{attrs:{id:"avl树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#avl树"}},[_._v("#")]),_._v(" AVL树")]),_._v(" "),v("ul",[v("li",[_._v("高度平衡的二叉查找树")]),_._v(" "),v("li",[v("strong",[_._v("左子树和右子树的高度相参不会超过1")]),_._v("，最大是1")])]),_._v(" "),v("h2",{attrs:{id:"红黑树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#红黑树"}},[_._v("#")]),_._v(" ==红黑树==")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("基础")]),_._v(" "),v("blockquote",[v("p",[_._v("​\t红黑树的英文是“Red-Black Tree”，简称 R-B Tree。"),v("strong",[_._v("它是一种不严格的平衡二叉查找树")]),_._v("，我前面说了，它的定义是不严格符合平衡二叉查找树的定义的。")]),_._v(" "),v("p",[_._v("​\t"),v("strong",[_._v("红黑树中的节点，一类被标记为黑色，一类被标记为红色。")])])]),_._v(" "),v("ul",[v("li",[v("p",[_._v("==红黑树的要求==")]),_._v(" "),v("blockquote",[v("ol",[v("li",[v("p",[_._v("根节点是黑色的；")])]),_._v(" "),v("li",[v("p",[_._v("每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；")])]),_._v(" "),v("li",[v("p",[_._v("任何相邻(这里值得是父亲和孩子)的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的(上下分隔)；")])]),_._v(" "),v("li",[v("p",[_._v("每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；")])])]),_._v(" "),v("p",[v("img",{attrs:{src:"/assets/%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%911.webp",alt:""}})])])])])]),_._v(" "),v("li",[v("p",[_._v("近似平衡特性")]),_._v(" "),v("blockquote",[v("p",[_._v("​\t平衡二叉查找树的初衷，是为了解决二叉查找树因为动态更新导致的性能退化问题。所以，“平衡”的意思可以等价为性能不退化。“近似平衡”就等价为性能不会退化得太严重。")]),_._v(" "),v("p",[_._v("​\t**红黑树的高度稳定地趋近 log2n **")])]),_._v(" "),v("ul",[v("li",[v("p",[_._v("首先，将红色节点从红黑树中去掉，那单纯包含黑色节点的红黑树的高度是多少呢？")]),_._v(" "),v("blockquote",[v("p",[_._v("​\t"),v("strong",[_._v("红色节点删除之后")]),_._v("，有些节点就没有父节点了，它们会直接拿这些节点的祖父节点（父节点的父节点）作为父节点。"),v("strong",[_._v("所以，之前的二叉树就变成了四叉树。")])]),_._v(" "),v("p",[_._v("​\t因为"),v("strong",[_._v("从任意节点到可达的叶子节点的每个路径包含相同数目的黑色节点")])]),_._v(" "),v("p",[_._v("​\t我们从四叉树中取出某些节点，放到叶节点位置，四叉树就变成了完全二叉树。"),v("strong",[_._v("所以，仅包含黑色节点的四叉树的高度，比包含相同节点个数的完全二叉树的高度还要小。")])]),_._v(" "),v("p",[_._v("​\t==即黑树高度不超过log~2~n==")])])])]),_._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"/assets/算法/红黑树去红.webp"}}),_._v(" "),v("ul",[v("li",[v("p",[_._v("把红色节点加回去，高度会变成多少呢？")]),_._v(" "),v("blockquote",[v("p",[_._v("​\t在红黑树中，红色节点不能相邻，也就是说，"),v("strong",[_._v("有一个红色节点就要至少有一个黑色节点，将它跟其他红色节点隔开。")])]),_._v(" "),v("p",[_._v("​\t"),v("strong",[_._v("红黑树中包含最多黑色节点的路径不会超过 log2n，所以加入红色节点之后，最长路径不会超过 2log2n")]),_._v("，也就是说，红黑树的高度近似 2log2n。")]),_._v(" "),v("p",[_._v("​\t"),v("strong",[_._v("这样推导出来的结果不够精确，实际上红黑树的性能更好。")])])])])])]),_._v(" "),v("li",[v("p",[_._v("为什么喜欢红黑树")]),_._v(" "),v("blockquote",[v("p",[_._v("​\t"),v("strong",[_._v("AVL 树是一种高度平衡的二叉树")]),_._v("，所以查找的效率非常高，但是，有利就有弊，AVL 树为了维持这种高度的平衡，就要付出更多的代价。"),v("strong",[_._v("每次插入、删除都要做调整，就比较复杂、耗时")]),_._v("。所以，对于有频繁的插入、删除操作的数据集合，使用 AVL 树的代价就有点高了。")]),_._v(" "),v("p",[_._v("​\t**红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比 AVL 树要低。**所以，红黑树的插入、删除、查找各种操作性能都比较稳定。")])])]),_._v(" "),v("li",[v("p",[v("a",{attrs:{href:"https://blog.csdn.net/fei33423/article/details/79132930",target:"_blank",rel:"noopener noreferrer"}},[_._v("红黑树和2-3树的关系"),v("OutboundLink")],1)]),_._v(" "),v("ul",[v("li",[v("p",[_._v("颜色表示")]),_._v(" "),v("blockquote",[v("p",[_._v("​\t因为每个结点都只会有一条指向自己的链接（从它的父结点指向它），"),v("strong",[_._v("我们将链接的颜色保存在表示结点的Node数据类型的布尔变量color中")]),_._v("（若指向它的链接是红色的，那么该变量为true，黑色则为false）。")]),_._v(" "),v("p",[_._v("​\t"),v("strong",[_._v("当我们提到一个结点颜色时，我们指的是指向该结点的链接的颜色")])])])]),_._v(" "),v("li",[v("p",[_._v("关系")]),_._v(" "),v("blockquote",[v("p",[_._v("​\t红黑树是从2-3树上演变而来的，具体请了解网址内容。")]),_._v(" "),v("p",[_._v("​\t==红黑树就是用红链接表示3-结点的2-3树==")]),_._v(" "),v("p",[_._v("​\t"),v("strong",[_._v("如果我们将一颗红黑树中的红链接画平")]),_._v("，那么所有的空链接到根结点的距离都将是相同的。如果我们将由红链接相连的结点合并，得到的就是一颗2-3树。")]),_._v(" "),v("p",[v("img",{attrs:{src:"/assets/%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%912-3%E6%A0%91.png",alt:""}})])])])])]),_._v(" "),v("li",[v("p",[v("a",{attrs:{href:"https://time.geekbang.org/column/article/68976",target:"_blank",rel:"noopener noreferrer"}},[_._v("红黑树实现"),v("OutboundLink")],1)]),_._v(" "),v("blockquote",[v("p",[_._v("​\t红黑树实现，其实近似于魔方还原，都有固定步骤，具体实现不要求掌握，能看懂过程就行。")])])]),_._v(" "),v("li",[v("p",[_._v("==关于红黑树==")]),_._v(" "),v("blockquote",[v("p",[_._v("​\t**红黑树是一种平衡二叉查找树。**它是为了解决普通二叉查找树在数据更新的过程中，复杂度退化的问题而产生的。")]),_._v(" "),v("p",[_._v("​\t**红黑树的高度近似 log2n，**所以它是近似平衡，插入、删除、查找操作的时间复杂度都是 O(logn)。")]),_._v(" "),v("p",[_._v("​\t"),v("strong",[_._v("因为红黑树是一种性能非常稳定的二叉查找树")]),_._v("，所以，在工程中，但凡是用到动态插入、删除、查找数据的场景，都可以用到它。")]),_._v(" "),v("p",[_._v("​\t不过，它实现起来比较复杂，如果自己写代码实现，难度会有些高，这个时候，我们其实更倾向用==跳表==来替代它。")])])])]),_._v(" "),v("h2",{attrs:{id:"递归树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#递归树"}},[_._v("#")]),_._v(" 递归树")]),_._v(" "),v("p",[v("strong",[_._v("借助递归树来分析递归算法的时间复杂度")])]),_._v(" "),v("p",[v("strong",[_._v("还可以"),v("a",{attrs:{href:"https://time.geekbang.org/column/article/41913",target:"_blank",rel:"noopener noreferrer"}},[_._v("借助递推公式来分析时间复杂度"),v("OutboundLink")],1)])]),_._v(" "),v("ul",[v("li",[v("p",[_._v("归并排序分析")]),_._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"/assets/算法/归并排序递归树.webp"}}),_._v(" "),v("blockquote",[v("p",[_._v("​\t归并算法中比较耗时的是归并操作，也就是把两个子数组合并为大数组。从图中我们可以看出，每一层归并操作消耗的时间总和是一样的，跟要排序的数据规模有关。"),v("strong",[_._v("我们把每一层归并操作消耗的时间记作 n。")])]),_._v(" "),v("p",[_._v("​\t我们只需要知道这棵树的高度 h，用高度 h 乘以每一层的时间消耗 n，"),v("strong",[_._v("就可以得到总的时间复杂度 O(n∗h)。")])]),_._v(" "),v("p",[_._v("​\t归并排序递归树是一棵满二叉树。我们前两节中讲到，满二叉树的高度大约是 log2n，所以，"),v("strong",[_._v("归并排序递归实现的时间复杂度就是 O(nlogn)。")])])])]),_._v(" "),v("li",[v("p",[_._v("快速排序分析")]),_._v(" "),v("blockquote",[v("p",[_._v("​\t快速排序在最好情况下，每次分区都能一分为二，这个时候用递推公式 T(n)=2T(2n)+n，很容易就能推导出时间复杂度是 O(nlogn),就跟归并排序相当。")]),_._v(" "),v("p",[_._v("​\t我们假设平均情况下，每次分区之后，两个分区的大小比例为 1:k。递归树图绘制如下：")])]),_._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"/assets/算法/快速排序递归树.webp"}}),_._v(" "),v("blockquote",[v("p",[_._v("​\t"),v("strong",[_._v("快速排序的过程中，每次分区都要遍历待分区区间的所有数据")]),_._v("，所以，每一层分区操作所遍历的数据的个数之和就是 n。我们现在只要求出递归树的高度 h，这个快排过程遍历的数据个数就是 h∗n ，也就是说，时间复杂度就是 O(h∗n)。")]),_._v(" "),v("p",[_._v("​\t因为每次分区并不是均匀地一分为二，所以递归树并不是满二叉树。这样一个递归树的高度是多少呢？")]),_._v(" "),v("p",[_._v("​\t我们知道，快速排序结束的条件就是待排序的小区间，大小为 1，也就是说叶子节点里的数据规模是 1。从根节点 n 到叶子节点 1，递归树中最短的一个路径每次都乘以 1/10，最长的一个路径每次都乘以 9/10。通过计算，我们可以得到，从根节点到叶子节点的最短路径是 log~10~n，最长的路径是 log~10/9~n。")]),_._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"/assets/算法/快排路径长度计算.webp"}}),_._v(" "),v("p",[_._v("​\t所以，遍历数据的个数总和就介于 nlog10n 和 nlog910n 之间。根据复杂度的大 O 表示法，对数复杂度的底数不管是多少，我们统一写成 logn，所以，当分区大小比例是 1:9 时，"),v("strong",[_._v("快速排序的时间复杂度仍然是 O(nlogn)。")])])])]),_._v(" "),v("li",[v("p",[_._v("斐波那契数列分析")]),_._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"/assets/算法/斐波那契递归树.webp"}}),_._v(" "),v("blockquote",[v("p",[_._v("​\tf(n) 分解为 f(n−1) 和 f(n−2)，每次数据规模都是 −1 或者 −2，叶子节点的数据规模是 1 或者 2。所以，从根节点走到叶子节点，每条路径是长短不一的。如果每次都是 −1，那最长路径大约就是 n；如果每次都是 −2，那最短路径大约就是 n/2。")]),_._v(" "),v("p",[_._v("​\t"),v("strong",[_._v("每次分解之后的合并操作只需要一次加法运算")]),_._v("，我们把这次加法运算的时间消耗记作 1。所以，从上往下，第一层的总时间消耗是 1，第二层的总时间消耗是 2，第三层的总时间消耗就是 22。**依次类推，第 k 层的时间消耗就是 2k−1，**那整个算法的总的时间消耗就是每一层时间消耗之和。")]),_._v(" "),v("p",[_._v("​\t如果路径长度都为 n，那这个总和就是 2^n^-1")]),_._v(" "),v("p",[_._v("​\t如果路径长度都是 n/2 ，那整个算法的总的时间消耗就是 2^n/2^−1。")]),_._v(" "),v("p",[_._v("​\t这个算法的时间复杂度就介于 O(2^n^) 和 O(2^n/2^) 之间。虽然这样得到的结果还不够精确，只是一个范围，"),v("strong",[_._v("但是我们也基本上知道了上面算法的时间复杂度是指数级的，非常高。")])])])])])])}),[],!1,null,null,null);v.default=l.exports}}]);
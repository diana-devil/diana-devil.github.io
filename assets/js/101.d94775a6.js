(window.webpackJsonp=window.webpackJsonp||[]).push([[101],{441:function(_,v,t){"use strict";t.r(v);var l=t(2),n=Object(l.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("p",[v("img",{attrs:{src:"/assets/%E5%90%8E%E7%AB%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E8%BF%9B%E9%98%B6/%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%E6%80%BB%E7%BB%93.png",alt:""}})]),_._v(" "),v("ul",[v("li",[v("p",[_._v("第一级nginx 负责 "),v("strong",[_._v("静态资源存储")]),_._v("和"),v("strong",[_._v("反向代理")])]),_._v(" "),v("ul",[v("li",[_._v("将请求路由到openResty的nginx集群中")])])]),_._v(" "),v("li",[v("p",[_._v("第二级nginx集群 实现"),v("strong",[_._v("第一级缓存")]),_._v("，即"),v("strong",[_._v("nginx本地缓存")])]),_._v(" "),v("div",{staticClass:"language-nginx extra-class"},[v("pre",{pre:!0,attrs:{class:"language-nginx"}},[v("code",[_._v(" "),v("span",{pre:!0,attrs:{class:"token comment"}},[_._v("# 共享字典，也就是本地缓存，名称叫做：item_cache，大小150M")]),_._v("\n "),v("span",{pre:!0,attrs:{class:"token directive"}},[v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("lua_shared_dict")]),_._v(" item_cache "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("150m")])]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v(" \n")])])]),v("ul",[v("li",[v("strong",[_._v("当请求路由到此时，它优先查询本地缓存，本地缓存没有在查询redis缓存，redis缓存没有在去访问tomcat端口获得信息")]),_._v(" "),v("ul",[v("li",[_._v("访问的代码逻辑，用lua语言编写，在"),v("code",[_._v("/usr/local/openresty/nginx/lua/item.lua")]),_._v("中")]),_._v(" "),v("li",[_._v("编写了一些 封装好的函数，在 "),v("code",[_._v("/usr/local/openresty/lualib/common.lua")]),_._v("中")])])]),_._v(" "),v("li",[_._v("在访问tomcat集群的时候，因为tomcat内部做了进程缓存，但是进程之间缓存不共享，所以在路由请求时不采用默认的轮询测策略，"),v("strong",[_._v("而采用根据访问路径 hash 的方法")]),_._v("，基于ID负载均衡。\n"),v("ul",[v("li",[_._v("如果访问同一个路径，则必然得到同一个hash值，则必然访问到同一个tomcat进程。")]),_._v(" "),v("li",[_._v("这样就可以极大的利用tomcat的进程缓存。")])])])])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("第二级缓存即为redis缓存")])]),_._v(" "),v("ul",[v("li",[_._v("为了避免项目刚启动时，因为reids缓存中无数据导致对mysql冲击较大，所以要进行"),v("strong",[_._v("redis缓存预热")]),_._v("，将热点信息提前放到reids中，减少数据库的压力")]),_._v(" "),v("li",[_._v("实现 接口 "),v("code",[_._v("InitializingBean")]),_._v(" 及其内部定义的方法"),v("code",[_._v("afterPropertiesSet()")])]),_._v(" "),v("li",[_._v("在设置键值对的时候， "),v("strong",[_._v("键要加前缀，归位同一类")]),_._v("，避免键冲突\n"),v("ul",[v("li",[v("code",[_._v("item:id:10001")])]),_._v(" "),v("li",[v("code",[_._v("item:stock:id:10001")])])])])])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("第三级缓存即为tomcat进程缓存")])]),_._v(" "),v("ul",[v("li",[_._v("借助 "),v("code",[_._v("Caffeine")]),_._v("框架实现进程缓存")]),_._v(" "),v("li",[_._v("各个进程间 缓存不共享")])])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("缓存同步")])]),_._v(" "),v("ul",[v("li",[_._v("nginx本地缓存 的缓存同步策略为\n"),v("ul",[v("li",[v("strong",[_._v("设置有效期")]),_._v("：给缓存设置有效期，到期后自动删除。再次查询时更新")])])]),_._v(" "),v("li",[_._v("redis缓存和tomcat进程缓存 的缓存同步策略为\n"),v("ul",[v("li",[_._v("**异步通知：**修改数据库时发送事件通知，相关服务监听到通知后修改缓存数据\n"),v("ul",[v("li",[_._v("使用"),v("code",[_._v("canal")]),_._v("监听数据库变化，当数据发生变化时，自动修改缓存\n"),v("ul",[v("li",[_._v("使用 "),v("code",[_._v("canal")]),_._v("做监听器，可以实现代码0侵入，只需要实现接口"),v("code",[_._v("EntryHandler<Item>")]),_._v(" "),v("ul",[v("li",[_._v("实现接口的三个方法")]),_._v(" "),v("li",[_._v("在实体类字段加上一些注解，来更好的与数据库建立联系")])])]),_._v(" "),v("li",[v("strong",[v("code",[_._v("canal")]),_._v("监听的原理与mysql的主从同步一致")]),_._v(" "),v("ul",[v("li",[_._v("它伪装成一个slave，通过监听数据库master的"),v("code",[_._v("binary log")]),_._v("，来实现实时的数据监听")])])])])]),_._v(" "),v("li",[_._v("当然也可以使用 mq")])])])])])])])])])}),[],!1,null,null,null);v.default=n.exports}}]);
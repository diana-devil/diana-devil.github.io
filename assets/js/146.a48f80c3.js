(window.webpackJsonp=window.webpackJsonp||[]).push([[146],{484:function(v,_,s){"use strict";s.r(_);var a=s(2),t=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"springcloud常见组件有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#springcloud常见组件有哪些"}},[v._v("#")]),v._v(" SpringCloud常见组件有哪些？")]),v._v(" "),_("p",[_("strong",[v._v("问题说明")]),v._v("：这个题目主要考察对SpringCloud的组件基本了解")]),v._v(" "),_("p",[_("strong",[v._v("难易程度")]),v._v("：简单")]),v._v(" "),_("p",[_("strong",[v._v("参考话术")]),v._v("：")]),v._v(" "),_("p",[v._v("SpringCloud包含的组件很多，有很多功能是重复的。其中最常用组件包括：")]),v._v(" "),_("p",[v._v("•注册中心组件：Eureka、Nacos等")]),v._v(" "),_("p",[v._v("•负载均衡组件：Ribbon")]),v._v(" "),_("p",[v._v("•远程调用组件：OpenFeign")]),v._v(" "),_("p",[v._v("•网关组件：Zuul、Gateway")]),v._v(" "),_("p",[v._v("•服务保护组件：Hystrix、Sentinel")]),v._v(" "),_("p",[v._v("•服务配置管理组件：SpringCloudConfig、Nacos")]),v._v(" "),_("h2",{attrs:{id:"nacos的服务注册表结构是怎样的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nacos的服务注册表结构是怎样的"}},[v._v("#")]),v._v(" Nacos的服务注册表结构是怎样的？")]),v._v(" "),_("p",[_("strong",[v._v("问题说明")]),v._v("：考察对Nacos数据分级结构的了解，以及Nacos源码的掌握情况")]),v._v(" "),_("p",[_("strong",[v._v("难易程度")]),v._v("：一般")]),v._v(" "),_("p",[_("strong",[v._v("参考话术")]),v._v("：")]),v._v(" "),_("p",[v._v("Nacos采用了数据的分级存储模型，最外层是Namespace，用来隔离环境。然后是Group，用来对服务分组。接下来就是服务（Service）了，一个服务包含多个实例，但是可能处于不同机房，因此Service下有多个集群（Cluster），Cluster下是不同的实例（Instance）。")]),v._v(" "),_("p",[v._v("对应到Java代码中，Nacos采用了一个多层的Map来表示。结构为Map<String, Map<String, Service>>，其中最外层Map的key就是namespaceId，值是一个Map。内层Map的key是group拼接serviceName，值是Service对象。Service对象内部又是一个Map，key是集群名称，值是Cluster对象。而Cluster对象内部维护了Instance的集合。")]),v._v(" "),_("p",[v._v("如图：")]),v._v(" "),_("p",[_("img",{attrs:{src:"/assets/%E9%9D%A2%E8%AF%95/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20210925215305446.png",alt:"image-20210925215305446"}})]),v._v(" "),_("h2",{attrs:{id:"nacos如何支撑阿里内部数十万服务注册压力"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nacos如何支撑阿里内部数十万服务注册压力"}},[v._v("#")]),v._v(" Nacos如何支撑阿里内部数十万服务注册压力？")]),v._v(" "),_("p",[_("strong",[v._v("问题说明")]),v._v("：考察对Nacos源码的掌握情况")]),v._v(" "),_("p",[_("strong",[v._v("难易程度")]),v._v("：难")]),v._v(" "),_("p",[_("strong",[v._v("参考话术")]),v._v("：")]),v._v(" "),_("p",[v._v("Nacos内部接收到注册的请求时，不会立即写数据，而是将服务注册的任务放入一个阻塞队列就立即响应给客户端。然后利用线程池读取阻塞队列中的任务，异步来完成实例更新，从而提高并发写能力。")]),v._v(" "),_("h2",{attrs:{id:"nacos如何避免并发读写冲突问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nacos如何避免并发读写冲突问题"}},[v._v("#")]),v._v(" Nacos如何避免并发读写冲突问题？")]),v._v(" "),_("p",[_("strong",[v._v("问题说明")]),v._v("：考察对Nacos源码的掌握情况")]),v._v(" "),_("p",[_("strong",[v._v("难易程度")]),v._v("：难")]),v._v(" "),_("p",[_("strong",[v._v("参考话术")]),v._v("：")]),v._v(" "),_("p",[v._v("Nacos在更新实例列表时，会采用CopyOnWrite技术，首先将旧的实例列表拷贝一份，然后更新拷贝的实例列表，再用更新后的实例列表来覆盖旧的实例列表。")]),v._v(" "),_("p",[v._v("这样在更新的过程中，就不会对读实例列表的请求产生影响，也不会出现脏读问题了。")]),v._v(" "),_("h2",{attrs:{id:"nacos与eureka的区别有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nacos与eureka的区别有哪些"}},[v._v("#")]),v._v(" Nacos与Eureka的区别有哪些？")]),v._v(" "),_("p",[_("strong",[v._v("问题说明")]),v._v("：考察对Nacos、Eureka的底层实现的掌握情况")]),v._v(" "),_("p",[_("strong",[v._v("难易程度")]),v._v("：难")]),v._v(" "),_("p",[_("strong",[v._v("参考话术")]),v._v("：")]),v._v(" "),_("p",[v._v("Nacos与Eureka有相同点，也有不同之处，可以从以下几点来描述：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("接口方式")]),v._v("：Nacos与Eureka都对外暴露了Rest风格的API接口，用来实现服务注册、发现等功能")]),v._v(" "),_("li",[_("strong",[v._v("实例类型")]),v._v("：Nacos的实例有永久和临时实例之分；而Eureka只支持临时实例")]),v._v(" "),_("li",[_("strong",[v._v("健康检测")]),v._v("：Nacos对临时实例采用心跳模式检测，对永久实例采用主动请求来检测；Eureka只支持心跳模式")]),v._v(" "),_("li",[_("strong",[v._v("服务发现")]),v._v("：Nacos支持定时拉取和订阅推送两种模式；Eureka只支持定时拉取模式")])]),v._v(" "),_("h2",{attrs:{id:"sentinel的限流与gateway的限流有什么差别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#sentinel的限流与gateway的限流有什么差别"}},[v._v("#")]),v._v(" Sentinel的限流与Gateway的限流有什么差别？")]),v._v(" "),_("p",[_("strong",[v._v("问题说明")]),v._v("：考察对限流算法的掌握情况")]),v._v(" "),_("p",[_("strong",[v._v("难易程度")]),v._v("：难")]),v._v(" "),_("p",[_("strong",[v._v("参考话术")]),v._v("：")]),v._v(" "),_("p",[v._v("限流算法常见的有三种实现：滑动时间窗口、令牌桶算法、漏桶算法。Gateway则采用了基于Redis实现的令牌桶算法。")]),v._v(" "),_("p",[v._v("而Sentinel内部却比较复杂：")]),v._v(" "),_("ul",[_("li",[v._v("默认限流模式是基于滑动时间窗口算法")]),v._v(" "),_("li",[v._v("排队等待的限流模式则基于漏桶算法")]),v._v(" "),_("li",[v._v("而热点参数限流则是基于令牌桶算法")])]),v._v(" "),_("h2",{attrs:{id:"sentinel的线程隔离与hystix的线程隔离有什么差别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#sentinel的线程隔离与hystix的线程隔离有什么差别"}},[v._v("#")]),v._v(" Sentinel的线程隔离与Hystix的线程隔离有什么差别?")]),v._v(" "),_("p",[_("strong",[v._v("问题说明")]),v._v("：考察对线程隔离方案的掌握情况")]),v._v(" "),_("p",[_("strong",[v._v("难易程度")]),v._v("：一般")]),v._v(" "),_("p",[_("strong",[v._v("参考话术")]),v._v("：")]),v._v(" "),_("p",[v._v("Hystix默认是基于线程池实现的线程隔离，每一个被隔离的业务都要创建一个独立的线程池，线程过多会带来额外的CPU开销，性能一般，但是隔离性更强。")]),v._v(" "),_("p",[v._v("Sentinel是基于信号量（计数器）实现的线程隔离，不用创建线程池，性能较好，但是隔离性一般。")])])}),[],!1,null,null,null);_.default=t.exports}}]);
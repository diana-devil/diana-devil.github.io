(window.webpackJsonp=window.webpackJsonp||[]).push([[130],{466:function(v,_,l){"use strict";l.r(_);var t=l(2),i=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"贪心算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#贪心算法"}},[v._v("#")]),v._v(" 贪心算法")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("经典应用")]),v._v(" "),_("ul",[_("li",[v._v("霍夫曼编码")]),v._v(" "),_("li",[v._v("Prim 和 Kruskal 最小生成树算法")]),v._v(" "),_("li",[v._v("Dijkstra 单源最短路径算法")])])]),v._v(" "),_("li",[_("p",[v._v("贪心算法步骤")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("当我们看到"),_("strong",[v._v("这类问题")]),v._v("的时候，首先要联想到贪心算法")]),v._v(" "),_("ul",[_("li",[v._v("针对一组数据，我们定义了"),_("strong",[v._v("限制值和期望值")]),v._v("，希望从中选出几个数据，在满足限制值的情况下，期望值最大。")]),v._v(" "),_("li",[v._v("当"),_("strong",[v._v("前一步的选择不会影响下一步的选择")]),v._v("的时候，考虑贪心算法。\n"),_("ul",[_("li",[v._v("例如背包问题，就一直找最大，填满背包即可。可以用贪心算法")]),v._v(" "),_("li",[v._v("例如0-1背包问题，一直找最大的话，会限制背包空间，从而影响下一件物品的选择，不适合用贪心")]),v._v(" "),_("li",[v._v("例如最短路径问题，一直找最小的话，一般都不是最小，因为选择了最小路径之后，接下来要选择的路会受到影响。")])])])])]),v._v(" "),_("li",[_("p",[v._v("我们尝试看下这个问题是否可以用贪心算法解决")])]),v._v(" "),_("li",[_("p",[v._v("我们举几个例子看下贪心算法产生的结果是否是最优的")]),v._v(" "),_("ul",[_("li",[v._v("大部分情况下，举几个例子验证一下就可以了。")])])])])])])])}),[],!1,null,null,null);_.default=i.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[147],{485:function(v,_,a){"use strict";a.r(_);var i=a(2),t=Object(i.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"你们为什么选择了rabbitmq而不是其它的mq"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#你们为什么选择了rabbitmq而不是其它的mq"}},[v._v("#")]),v._v(" 你们为什么选择了RabbitMQ而不是其它的MQ？")]),v._v(" "),_("p",[v._v("如图：")]),v._v(" "),_("p",[_("img",{attrs:{src:"/assets/%E9%9D%A2%E8%AF%95/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20210925220034702.png",alt:"image-20210925220034702"}})]),v._v(" "),_("p",[_("strong",[v._v("话术：")])]),v._v(" "),_("p",[v._v("kafka是以吞吐量高而闻名，不过其数据稳定性一般，而且无法保证消息有序性。我们公司的日志收集也有使用，业务模块中则使用的RabbitMQ。")]),v._v(" "),_("p",[v._v("阿里巴巴的RocketMQ基于Kafka的原理，弥补了Kafka的缺点，继承了其高吞吐的优势，其客户端目前以Java为主。但是我们担心阿里巴巴开源产品的稳定性，所以就没有使用。")]),v._v(" "),_("p",[v._v("RabbitMQ基于面向并发的语言Erlang开发，吞吐量不如Kafka，但是对我们公司来讲够用了。而且消息可靠性较好，并且消息延迟极低，集群搭建比较方便。支持多种协议，并且有各种语言的客户端，比较灵活。Spring对RabbitMQ的支持也比较好，使用起来比较方便，比较符合我们公司的需求。")]),v._v(" "),_("p",[v._v("综合考虑我们公司的并发需求以及稳定性需求，我们选择了RabbitMQ。")]),v._v(" "),_("h2",{attrs:{id:"rabbitmq如何确保消息的不丢失"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq如何确保消息的不丢失"}},[v._v("#")]),v._v(" RabbitMQ如何确保消息的不丢失？")]),v._v(" "),_("p",[_("strong",[v._v("话术：")])]),v._v(" "),_("p",[v._v("RabbitMQ针对消息传递过程中可能发生问题的各个地方，给出了针对性的解决方案：")]),v._v(" "),_("ul",[_("li",[v._v("生产者发送消息时可能因为网络问题导致消息没有到达交换机：\n"),_("ul",[_("li",[v._v("RabbitMQ提供了publisher confirm机制\n"),_("ul",[_("li",[v._v("生产者发送消息后，可以编写ConfirmCallback函数")]),v._v(" "),_("li",[v._v("消息成功到达交换机后，RabbitMQ会调用ConfirmCallback通知消息的发送者，返回ACK")]),v._v(" "),_("li",[v._v("消息如果未到达交换机，RabbitMQ也会调用ConfirmCallback通知消息的发送者，返回NACK")]),v._v(" "),_("li",[v._v("消息超时未发送成功也会抛出异常")])])])])]),v._v(" "),_("li",[v._v("消息到达交换机后，如果未能到达队列，也会导致消息丢失：\n"),_("ul",[_("li",[v._v("RabbitMQ提供了publisher return机制\n"),_("ul",[_("li",[v._v("生产者可以定义ReturnCallback函数")]),v._v(" "),_("li",[v._v("消息到达交换机，未到达队列，RabbitMQ会调用ReturnCallback通知发送者，告知失败原因")])])])])]),v._v(" "),_("li",[v._v("消息到达队列后，MQ宕机也可能导致丢失消息：\n"),_("ul",[_("li",[v._v("RabbitMQ提供了持久化功能，集群的主从备份功能\n"),_("ul",[_("li",[v._v("消息持久化，RabbitMQ会将交换机、队列、消息持久化到磁盘，宕机重启可以恢复消息")]),v._v(" "),_("li",[v._v("镜像集群，仲裁队列，都可以提供主从备份功能，主节点宕机，从节点会自动切换为主，数据依然在")])])])])]),v._v(" "),_("li",[v._v("消息投递给消费者后，如果消费者处理不当，也可能导致消息丢失\n"),_("ul",[_("li",[v._v("SpringAMQP基于RabbitMQ提供了消费者确认机制、消费者重试机制，消费者失败处理策略：\n"),_("ul",[_("li",[v._v("消费者的确认机制：\n"),_("ul",[_("li",[v._v("消费者处理消息成功，未出现异常时，Spring返回ACK给RabbitMQ，消息才被移除")]),v._v(" "),_("li",[v._v("消费者处理消息失败，抛出异常，宕机，Spring返回NACK或者不返回结果，消息不被异常")])])]),v._v(" "),_("li",[v._v("消费者重试机制：\n"),_("ul",[_("li",[v._v("默认情况下，消费者处理失败时，消息会再次回到MQ队列，然后投递给其它消费者。Spring提供的消费者重试机制，则是在处理失败后不返回NACK，而是直接在消费者本地重试。多次重试都失败后，则按照消费者失败处理策略来处理消息。避免了消息频繁入队带来的额外压力。")])])]),v._v(" "),_("li",[v._v("消费者失败策略：\n"),_("ul",[_("li",[v._v("当消费者多次本地重试失败时，消息默认会丢弃。")]),v._v(" "),_("li",[v._v("Spring提供了Republish策略，在多次重试都失败，耗尽重试次数后，将消息重新投递给指定的异常交换机，并且会携带上异常栈信息，帮助定位问题。")])])])])])])])]),v._v(" "),_("h2",{attrs:{id:"rabbitmq如何避免消息堆积"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq如何避免消息堆积"}},[v._v("#")]),v._v(" RabbitMQ如何避免消息堆积？")]),v._v(" "),_("p",[_("strong",[v._v("话术：")])]),v._v(" "),_("p",[v._v("消息堆积问题产生的原因往往是因为消息发送的速度超过了消费者消息处理的速度。因此解决方案无外乎以下三点：")]),v._v(" "),_("ul",[_("li",[v._v("提高消费者处理速度")]),v._v(" "),_("li",[v._v("增加更多消费者")]),v._v(" "),_("li",[v._v("增加队列消息存储上限")])]),v._v(" "),_("p",[v._v("1）提高消费者处理速度")]),v._v(" "),_("p",[v._v("消费者处理速度是由业务代码决定的，所以我们能做的事情包括：")]),v._v(" "),_("ul",[_("li",[v._v("尽可能优化业务代码，提高业务性能")]),v._v(" "),_("li",[v._v("接收到消息后，开启线程池，并发处理多个消息")])]),v._v(" "),_("p",[v._v("优点：成本低，改改代码即可")]),v._v(" "),_("p",[v._v("缺点：开启线程池会带来额外的性能开销，对于高频、低时延的任务不合适。推荐任务执行周期较长的业务。")]),v._v(" "),_("p",[v._v("2）增加更多消费者")]),v._v(" "),_("p",[v._v("一个队列绑定多个消费者，共同争抢任务，自然可以提供消息处理的速度。")]),v._v(" "),_("p",[v._v("优点：能用钱解决的问题都不是问题。实现简单粗暴")]),v._v(" "),_("p",[v._v("缺点：问题是没有钱。成本太高")]),v._v(" "),_("p",[v._v("3）增加队列消息存储上限")]),v._v(" "),_("p",[v._v("在RabbitMQ的1.8版本后，加入了新的队列模式：Lazy Queue")]),v._v(" "),_("p",[v._v("这种队列不会将消息保存在内存中，而是在收到消息后直接写入磁盘中，理论上没有存储上限。可以解决消息堆积问题。")]),v._v(" "),_("p",[v._v("优点：磁盘存储更安全；存储无上限；避免内存存储带来的Page Out问题，性能更稳定；")]),v._v(" "),_("p",[v._v("缺点：磁盘存储受到IO性能的限制，消息时效性不如内存模式，但影响不大。")]),v._v(" "),_("h2",{attrs:{id:"rabbitmq如何保证消息的有序性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq如何保证消息的有序性"}},[v._v("#")]),v._v(" RabbitMQ如何保证消息的有序性？")]),v._v(" "),_("p",[_("strong",[v._v("话术：")])]),v._v(" "),_("p",[v._v("其实RabbitMQ是队列存储，天然具备先进先出的特点，只要消息的发送是有序的，那么理论上接收也是有序的。不过当一个队列绑定了多个消费者时，可能出现消息轮询投递给消费者的情况，而消费者的处理顺序就无法保证了。")]),v._v(" "),_("p",[v._v("因此，要保证消息的有序性，需要做的下面几点：")]),v._v(" "),_("ul",[_("li",[v._v("保证消息发送的有序性")]),v._v(" "),_("li",[v._v("保证一组有序的消息都发送到同一个队列")]),v._v(" "),_("li",[v._v("保证一个队列只包含一个消费者")])]),v._v(" "),_("h2",{attrs:{id:"如何防止mq消息被重复消费"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何防止mq消息被重复消费"}},[v._v("#")]),v._v(" 如何防止MQ消息被重复消费？")]),v._v(" "),_("p",[_("strong",[v._v("话术：")])]),v._v(" "),_("p",[v._v("消息重复消费的原因多种多样，不可避免。所以只能从消费者端入手，只要能保证消息处理的幂等性就可以确保消息不被重复消费。")]),v._v(" "),_("p",[v._v("而幂等性的保证又有很多方案：")]),v._v(" "),_("ul",[_("li",[v._v("给每一条消息都添加一个唯一id，在本地记录消息表及消息状态，处理消息时基于数据库表的id唯一性做判断")]),v._v(" "),_("li",[v._v("同样是记录消息表，利用消息状态字段实现基于乐观锁的判断，保证幂等")]),v._v(" "),_("li",[v._v("基于业务本身的幂等性。比如根据id的删除、查询业务天生幂等；新增、修改等业务可以考虑基于数据库id唯一性、或者乐观锁机制确保幂等。本质与消息表方案类似。")])]),v._v(" "),_("h2",{attrs:{id:"如何保证rabbitmq的高可用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何保证rabbitmq的高可用"}},[v._v("#")]),v._v(" 如何保证RabbitMQ的高可用？")]),v._v(" "),_("p",[_("strong",[v._v("话术：")])]),v._v(" "),_("p",[v._v("要实现RabbitMQ的高可用无外乎下面两点：")]),v._v(" "),_("ul",[_("li",[v._v("做好交换机、队列、消息的持久化")]),v._v(" "),_("li",[v._v("搭建RabbitMQ的镜像集群，做好主从备份。当然也可以使用仲裁队列代替镜像集群。")])]),v._v(" "),_("h2",{attrs:{id:"使用mq可以解决那些问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#使用mq可以解决那些问题"}},[v._v("#")]),v._v(" 使用MQ可以解决那些问题？")]),v._v(" "),_("p",[_("strong",[v._v("话术：")])]),v._v(" "),_("p",[v._v("RabbitMQ能解决的问题很多，例如：")]),v._v(" "),_("ul",[_("li",[v._v("解耦合：将几个业务关联的微服务调用修改为基于MQ的异步通知，可以解除微服务之间的业务耦合。同时还提高了业务性能。")]),v._v(" "),_("li",[v._v("流量削峰：将突发的业务请求放入MQ中，作为缓冲区。后端的业务根据自己的处理能力从MQ中获取消息，逐个处理任务。流量曲线变的平滑很多")]),v._v(" "),_("li",[v._v("延迟队列：基于RabbitMQ的死信队列或者DelayExchange插件，可以实现消息发送后，延迟接收的效果。")])])])}),[],!1,null,null,null);_.default=t.exports}}]);
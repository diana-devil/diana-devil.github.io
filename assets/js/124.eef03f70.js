(window.webpackJsonp=window.webpackJsonp||[]).push([[124],{462:function(t,_,v){"use strict";v.r(_);var s=v(2),o=Object(s.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"基础知识"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基础知识"}},[t._v("#")]),t._v(" 基础知识")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("Redis 是用跳表来实现有序集合的")])]),t._v(" "),_("li",[t._v("跳表其实是由链表改造而来的，在原链表的基础上加上索引，在索引之上再加索引，通过空间换时间，以实现链表的”二分查找“。"),_("strong",[t._v("这种链表加多级索引的结构，就是跳表。")])]),t._v(" "),_("li",[t._v("它确实是一种各方面性能都比较优秀的动态数据结构，可以支持"),_("strong",[t._v("快速地插入、删除、查找")]),t._v("操作，写起来也不复杂，甚至可以替代红黑树（Red-black tree）")])]),t._v(" "),_("img",{staticStyle:{zoom:"50%"},attrs:{src:"/assets/算法/跳表1.webp"}}),t._v(" "),_("h2",{attrs:{id:"时间复杂度分析-o-logn"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度分析-o-logn"}},[t._v("#")]),t._v(" 时间复杂度分析——O(logn)")]),t._v(" "),_("blockquote",[_("p",[t._v("​\t每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是 n/2，第二级索引的结点个数大约就是 n/4，第三级索引的结点个数大约就是 n/8，依次类推，也就是说，第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，"),_("strong",[t._v("那第 k级索引结点的个数就是 n/(2k)。")])]),t._v(" "),_("p",[t._v("​\t假设索引有 h 级，最高级的索引有 2 个结点。通过上面的公式，我们可以得到 n/(2h)=2，从而求得 h=log2n-1。"),_("strong",[t._v("如果包含原始链表这一层，整个跳表的高度就是 ==log2n==。")])]),t._v(" "),_("p",[t._v("​\t我们在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 O(m*logn)。那这个 m 的值是多少呢？按照前面这种索引结构，"),_("strong",[t._v("我们每一级索引都最多只需要遍历 3 个结点")]),t._v("，也就是说 m=3，为什么是 3 呢？我来解释一下。 "),_("strong",[t._v("==2+1==——2是结点个数，每两个结点抽一层索引。")])]),t._v(" "),_("p",[t._v("​\t假设我们要查找的数据是 x，在第 k 级索引中，我们遍历到 y 结点之后，发现 x 大于 y，小于后面的结点 z，所以我们通过 y 的 down 指针，从第 k 级索引下降到第 k-1 级索引。在第 k-1 级索引中，y 和 z 之间只有 3 个结点（包含 y 和 z），所以，我们在 K-1 级索引中最多只需要遍历 3 个结点，依次类推，每一级索引都最多只需要遍历 3 个结点。")]),t._v(" "),_("p",[t._v("​\t通过上面的分析，我们得到 m=3，"),_("strong",[t._v("所以在跳表中查询任意数据的时间复杂度就是 ==O(logn)==。")])])]),t._v(" "),_("p",[_("img",{attrs:{src:"/assets/%E7%AE%97%E6%B3%95/%E8%B7%B3%E8%A1%A82.webp",alt:""}})]),t._v(" "),_("h2",{attrs:{id:"空间复杂度分析-o-n"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#空间复杂度分析-o-n"}},[t._v("#")]),t._v(" 空间复杂度分析——O(n)")]),t._v(" "),_("blockquote",[_("p",[t._v("​\t假设原始链表大小为 n，那第一级索引大约有 n/2 个结点，第二级索引大约有 n/4 个结点，以此类推，每上升一级就减少一半，直到剩下 2 个结点。如果我们把每层索引的结点数写出来，就是一个等比数列。")])]),t._v(" "),_("p",[_("img",{attrs:{src:"/assets/%E7%AE%97%E6%B3%95/%E8%B7%B3%E8%A1%A83.webp",alt:""}})]),t._v(" "),_("blockquote",[_("p",[t._v("​\t这几级索引的结点总和就是 n/2+n/4+n/8…+8+4+2=n-2。 一共是log~2~(n/2)项，n/2算是首项，公比为1/2，计算过程如下所示：")])]),t._v(" "),_("p",[t._v("$$\n\\frac{\\frac{n}{2}"),_("em",[t._v("(1-(\\frac{1}{2})^{log_{2}\\frac{n}{2}})}{1-\\frac{1}{2}}\n=n")]),t._v("(1-\\frac{2}{n})=n-2\n$$")]),t._v(" "),_("blockquote",[_("p",[t._v("​\t"),_("strong",[t._v("所以跳表的空间复杂度为O(n)")]),t._v("。也就是说，如果将包含 n 个结点的单链表构造成跳表，我们需要额外再用接近 n 个结点的存储空间。"),_("strong",[t._v("选择抽取结点个数越大，所需存储空间越小，性能也就越差。")])])]),t._v(" "),_("blockquote",[_("p",[t._v("​\t实际上，在软件开发中，"),_("strong",[t._v("我们不必太在意索引占用的额外空间")]),t._v("。在讲数据结构和算法时，我们习惯性地把要处理的数据看成整数，但是在实际的软件开发中，"),_("strong",[t._v("原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针")]),t._v("，并不需要存储对象，所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了。")])]),t._v(" "),_("h2",{attrs:{id:"高效的动态插入和删除"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#高效的动态插入和删除"}},[t._v("#")]),t._v(" 高效的动态插入和删除")]),t._v(" "),_("blockquote",[_("p",[t._v("​\t跳表这个动态数据结构，不仅支持查找操作，还支持动态的插入、删除操作，而且插入、删除操作的时间复杂度也是 O(logn)。")])]),t._v(" "),_("ul",[_("li",[_("p",[t._v("插入")]),t._v(" "),_("blockquote",[_("p",[t._v("​\t在单链表中，一旦定位好要插入的位置，插入结点的时间复杂度是很低的，就是 O(1)。但是，这里为了保证原始链表中数据的有序性，我们需要先找到要插入的位置，这个查找操作就会比较耗时。")]),t._v(" "),_("p",[t._v("​\t对于跳表来说，我们讲过查找某个结点的时间复杂度是 O(logn)，"),_("strong",[t._v("所以这里查找某个数据应该插入的位置，方法也是类似的，时间复杂度也是 O(logn)")]),t._v("。")]),t._v(" "),_("p",[t._v("​\t这里没有考虑索引的更新，动态更新索引在下方说明。")]),t._v(" "),_("p",[t._v("​")])]),t._v(" "),_("img",{staticStyle:{zoom:"50%"},attrs:{src:"/assets/算法/跳表插入.webp"}})]),t._v(" "),_("li",[_("p",[t._v("删除也是同样的道理，查找花费时间为O(logn),删除为O(1).")])])]),t._v(" "),_("h2",{attrs:{id:"跳表索引的动态更新"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#跳表索引的动态更新"}},[t._v("#")]),t._v(" 跳表索引的动态更新")]),t._v(" "),_("blockquote",[_("p",[t._v("​\t作为一种==动态数据结构==，我们需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。")])]),t._v(" "),_("p",[t._v("==跳表是通过随机函数来维护前面提到的“平衡性”==")]),t._v(" "),_("blockquote",[_("p",[t._v("​\t当我们往跳表中插入数据的时候，我们可以选择同时将这个数据插入到部分索引层中。")]),t._v(" "),_("p",[t._v("​\t如何选择加入哪些索引层呢？")]),t._v(" "),_("p",[t._v("​\t我们通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。")]),t._v(" "),_("p",[t._v("​\t"),_("strong",[t._v("随机函数的选择很有讲究，从概率上来讲，能够保证跳表的索引大小和数据大小平衡性，不至于性能过度退化。")])])]),t._v(" "),_("img",{staticStyle:{zoom:"50%"},attrs:{src:"/assets/算法/跳表动态更新.webp"}}),t._v(" "),_("h2",{attrs:{id:"跳表实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#跳表实现"}},[t._v("#")]),t._v(" 跳表实现")]),t._v(" "),_("p",[t._v("为什么 Redis 要用跳表来实现有序集合，而不是红黑树？")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("Redis 中的有序集合支持的核心操作主要有下面这几个：")]),t._v(" "),_("ul",[_("li",[t._v("插入一个数据")]),t._v(" "),_("li",[t._v("删除一个数据")]),t._v(" "),_("li",[t._v("查找一个数据")]),t._v(" "),_("li",[t._v("按照区间查找数据（比如查找值在[100, 356]之间的数据）")]),t._v(" "),_("li",[t._v("迭代输出有序序列")])]),t._v(" "),_("blockquote",[_("p",[t._v("​      插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。")]),t._v(" "),_("p",[t._v("​     但是，"),_("strong",[t._v("按照区间来查找数据这个操作")]),t._v("，红黑树的效率没有跳表高。对于按照区间查找数据这个操作，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了。这样做非常高效。")])])]),t._v(" "),_("li",[_("p",[t._v("跳表更容易代码实现。")])]),t._v(" "),_("li",[_("p",[t._v("跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。")])])])])}),[],!1,null,null,null);_.default=o.exports}}]);
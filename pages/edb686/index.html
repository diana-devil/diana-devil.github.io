<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Redis篇 | 凉冰的手记</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/favicon.ico">
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/icons/192.png">
    <link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#2196f3">
    <meta name="description" content="记录生活的精彩瞬间，记录一个程序猿的成长！">
    <meta name="keywords" content="琐事，小记">
    <meta name="author" href="凉冰">
    <meta name="theme-color" content="#2196f3">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/icons/144.png">
    <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/assets/css/0.styles.59ed400b.css" as="style"><link rel="preload" href="/assets/js/app.3ee2b30c.js" as="script"><link rel="preload" href="/assets/js/2.fc657b59.js" as="script"><link rel="preload" href="/assets/js/145.3f68756b.js" as="script"><link rel="preload" href="/assets/js/3.e0ec9727.js" as="script"><link rel="prefetch" href="/assets/js/10.eb4f1714.js"><link rel="prefetch" href="/assets/js/100.60572966.js"><link rel="prefetch" href="/assets/js/101.d94775a6.js"><link rel="prefetch" href="/assets/js/102.354c87f2.js"><link rel="prefetch" href="/assets/js/103.0322d8d3.js"><link rel="prefetch" href="/assets/js/104.330ce470.js"><link rel="prefetch" href="/assets/js/105.f2c0cf7b.js"><link rel="prefetch" href="/assets/js/106.9b15e481.js"><link rel="prefetch" href="/assets/js/107.f83846c8.js"><link rel="prefetch" href="/assets/js/108.fd868043.js"><link rel="prefetch" href="/assets/js/109.144984d2.js"><link rel="prefetch" href="/assets/js/11.1f4ed2b0.js"><link rel="prefetch" href="/assets/js/110.393075aa.js"><link rel="prefetch" href="/assets/js/111.8e2be411.js"><link rel="prefetch" href="/assets/js/112.f5db1301.js"><link rel="prefetch" href="/assets/js/113.c5a49956.js"><link rel="prefetch" href="/assets/js/114.f7400c29.js"><link rel="prefetch" href="/assets/js/115.0d4d9691.js"><link rel="prefetch" href="/assets/js/116.5e2d0bba.js"><link rel="prefetch" href="/assets/js/117.b9b6cd5c.js"><link rel="prefetch" href="/assets/js/118.cfffe6ca.js"><link rel="prefetch" href="/assets/js/119.faeb006b.js"><link rel="prefetch" href="/assets/js/12.c55c2945.js"><link rel="prefetch" href="/assets/js/120.2c87041a.js"><link rel="prefetch" href="/assets/js/121.6d6d525b.js"><link rel="prefetch" href="/assets/js/122.a378a709.js"><link rel="prefetch" href="/assets/js/123.8a44d7e0.js"><link rel="prefetch" href="/assets/js/124.eef03f70.js"><link rel="prefetch" href="/assets/js/125.20627b3b.js"><link rel="prefetch" href="/assets/js/126.02bdd70b.js"><link rel="prefetch" href="/assets/js/127.6aaf85c7.js"><link rel="prefetch" href="/assets/js/128.2f2f6b78.js"><link rel="prefetch" href="/assets/js/129.b1f7d667.js"><link rel="prefetch" href="/assets/js/13.b5382928.js"><link rel="prefetch" href="/assets/js/130.aadb5b72.js"><link rel="prefetch" href="/assets/js/131.0a0ad3b4.js"><link rel="prefetch" href="/assets/js/132.a05a0c00.js"><link rel="prefetch" href="/assets/js/133.584b8785.js"><link rel="prefetch" href="/assets/js/134.ab61764f.js"><link rel="prefetch" href="/assets/js/135.ccae4853.js"><link rel="prefetch" href="/assets/js/136.38fdaa61.js"><link rel="prefetch" href="/assets/js/137.502d74c0.js"><link rel="prefetch" href="/assets/js/138.12a12ee7.js"><link rel="prefetch" href="/assets/js/139.5ed042c0.js"><link rel="prefetch" href="/assets/js/14.9bf49d25.js"><link rel="prefetch" href="/assets/js/140.32ffb0bc.js"><link rel="prefetch" href="/assets/js/141.3b99bc3f.js"><link rel="prefetch" href="/assets/js/142.afd3e1e7.js"><link rel="prefetch" href="/assets/js/143.ad7b5934.js"><link rel="prefetch" href="/assets/js/144.7bdbdbd9.js"><link rel="prefetch" href="/assets/js/146.a48f80c3.js"><link rel="prefetch" href="/assets/js/147.eb3a30a3.js"><link rel="prefetch" href="/assets/js/148.563f4279.js"><link rel="prefetch" href="/assets/js/149.7627333e.js"><link rel="prefetch" href="/assets/js/15.47e2fe44.js"><link rel="prefetch" href="/assets/js/150.7cf4b6fd.js"><link rel="prefetch" href="/assets/js/151.200e2d36.js"><link rel="prefetch" href="/assets/js/152.68d5a6f8.js"><link rel="prefetch" href="/assets/js/153.4019d1b1.js"><link rel="prefetch" href="/assets/js/154.7c56b873.js"><link rel="prefetch" href="/assets/js/155.8a895428.js"><link rel="prefetch" href="/assets/js/156.9a106f9c.js"><link rel="prefetch" href="/assets/js/157.b585e3f5.js"><link rel="prefetch" href="/assets/js/158.a9ffbcc1.js"><link rel="prefetch" href="/assets/js/159.9bd41101.js"><link rel="prefetch" href="/assets/js/16.709e62a0.js"><link rel="prefetch" href="/assets/js/17.b149e3eb.js"><link rel="prefetch" href="/assets/js/18.5b57a250.js"><link rel="prefetch" href="/assets/js/19.d2aedd09.js"><link rel="prefetch" href="/assets/js/20.13fd637f.js"><link rel="prefetch" href="/assets/js/21.91dc71fa.js"><link rel="prefetch" href="/assets/js/22.b44ebaaf.js"><link rel="prefetch" href="/assets/js/23.85274bf7.js"><link rel="prefetch" href="/assets/js/24.fdcf9dad.js"><link rel="prefetch" href="/assets/js/25.d7834455.js"><link rel="prefetch" href="/assets/js/26.149bb0bb.js"><link rel="prefetch" href="/assets/js/27.fe47c303.js"><link rel="prefetch" href="/assets/js/28.106a053b.js"><link rel="prefetch" href="/assets/js/29.5cbd445a.js"><link rel="prefetch" href="/assets/js/30.bc8be6db.js"><link rel="prefetch" href="/assets/js/31.776bb22e.js"><link rel="prefetch" href="/assets/js/32.38f1617c.js"><link rel="prefetch" href="/assets/js/33.764d5e8e.js"><link rel="prefetch" href="/assets/js/34.ee4b3664.js"><link rel="prefetch" href="/assets/js/35.0c8a4552.js"><link rel="prefetch" href="/assets/js/36.3114f265.js"><link rel="prefetch" href="/assets/js/37.6623c809.js"><link rel="prefetch" href="/assets/js/38.47b2ae3c.js"><link rel="prefetch" href="/assets/js/39.66477360.js"><link rel="prefetch" href="/assets/js/4.7bd8ec5a.js"><link rel="prefetch" href="/assets/js/40.3c1369b3.js"><link rel="prefetch" href="/assets/js/41.ba422769.js"><link rel="prefetch" href="/assets/js/42.d8feaaee.js"><link rel="prefetch" href="/assets/js/43.7a023784.js"><link rel="prefetch" href="/assets/js/44.578065d4.js"><link rel="prefetch" href="/assets/js/45.599d10a9.js"><link rel="prefetch" href="/assets/js/46.68c58a57.js"><link rel="prefetch" href="/assets/js/47.a0e48134.js"><link rel="prefetch" href="/assets/js/48.a8edc4f3.js"><link rel="prefetch" href="/assets/js/49.a98d9884.js"><link rel="prefetch" href="/assets/js/5.bc317ee9.js"><link rel="prefetch" href="/assets/js/50.7001c5b8.js"><link rel="prefetch" href="/assets/js/51.43d17700.js"><link rel="prefetch" href="/assets/js/52.9ad031a9.js"><link rel="prefetch" href="/assets/js/53.8347b740.js"><link rel="prefetch" href="/assets/js/54.73a1db12.js"><link rel="prefetch" href="/assets/js/55.06ac4334.js"><link rel="prefetch" href="/assets/js/56.caf42a7a.js"><link rel="prefetch" href="/assets/js/57.c8af04ff.js"><link rel="prefetch" href="/assets/js/58.259c0df6.js"><link rel="prefetch" href="/assets/js/59.4a73da6e.js"><link rel="prefetch" href="/assets/js/6.da0024ba.js"><link rel="prefetch" href="/assets/js/60.c88072d5.js"><link rel="prefetch" href="/assets/js/61.a3a06ae4.js"><link rel="prefetch" href="/assets/js/62.e5adc7b0.js"><link rel="prefetch" href="/assets/js/63.48cc1305.js"><link rel="prefetch" href="/assets/js/64.86f8647c.js"><link rel="prefetch" href="/assets/js/65.005e380e.js"><link rel="prefetch" href="/assets/js/66.67bff065.js"><link rel="prefetch" href="/assets/js/67.e12b4c13.js"><link rel="prefetch" href="/assets/js/68.0161e8c6.js"><link rel="prefetch" href="/assets/js/69.5aaf7b82.js"><link rel="prefetch" href="/assets/js/7.1d00dc1d.js"><link rel="prefetch" href="/assets/js/70.6a645155.js"><link rel="prefetch" href="/assets/js/71.001a3225.js"><link rel="prefetch" href="/assets/js/72.2850a293.js"><link rel="prefetch" href="/assets/js/73.d250e0c6.js"><link rel="prefetch" href="/assets/js/74.dafa5bc3.js"><link rel="prefetch" href="/assets/js/75.22c6b92e.js"><link rel="prefetch" href="/assets/js/76.24bc0a51.js"><link rel="prefetch" href="/assets/js/77.e38213b8.js"><link rel="prefetch" href="/assets/js/78.a22de10e.js"><link rel="prefetch" href="/assets/js/79.b0e7fed2.js"><link rel="prefetch" href="/assets/js/8.b16448cb.js"><link rel="prefetch" href="/assets/js/80.67472401.js"><link rel="prefetch" href="/assets/js/81.1df69f3e.js"><link rel="prefetch" href="/assets/js/82.022c9317.js"><link rel="prefetch" href="/assets/js/83.8894e626.js"><link rel="prefetch" href="/assets/js/84.e9f038d8.js"><link rel="prefetch" href="/assets/js/85.ff3971f7.js"><link rel="prefetch" href="/assets/js/86.24e53411.js"><link rel="prefetch" href="/assets/js/87.95b56dc2.js"><link rel="prefetch" href="/assets/js/88.4557cc7d.js"><link rel="prefetch" href="/assets/js/89.1337890b.js"><link rel="prefetch" href="/assets/js/9.1b8d4154.js"><link rel="prefetch" href="/assets/js/90.29d24983.js"><link rel="prefetch" href="/assets/js/91.84b2e3eb.js"><link rel="prefetch" href="/assets/js/92.23e2abeb.js"><link rel="prefetch" href="/assets/js/93.162e9b76.js"><link rel="prefetch" href="/assets/js/94.9ada79ba.js"><link rel="prefetch" href="/assets/js/95.5cc24e13.js"><link rel="prefetch" href="/assets/js/96.0ee67f9e.js"><link rel="prefetch" href="/assets/js/97.9f98bf38.js"><link rel="prefetch" href="/assets/js/98.58600000.js"><link rel="prefetch" href="/assets/js/99.f8a36889.js">
    <link rel="stylesheet" href="/assets/css/0.styles.59ed400b.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/恶魔.webp" alt="凉冰的手记" class="logo"> <span class="site-name can-hide">凉冰的手记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">主页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="后端" class="dropdown-title"><a href="/Java-C/" class="link-title">后端</a> <span class="title" style="display:none;">后端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/back/java/" class="nav-link">Java</a></li><li class="dropdown-item"><!----> <a href="/back/javaWeb/" class="nav-link">JavaWeb</a></li><li class="dropdown-item"><!----> <a href="/back/sql/" class="nav-link">数据库</a></li><li class="dropdown-item"><!----> <a href="/back/SSM/" class="nav-link">SSM</a></li><li class="dropdown-item"><!----> <a href="/back/SpringBoot/" class="nav-link">SpringBoot</a></li><li class="dropdown-item"><!----> <a href="/back/Microservice/" class="nav-link">微服务</a></li></ul></div></div><div class="nav-item"><a href="/Algorithm/" class="nav-link">算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><a href="/technology/" class="link-title">技术</a> <span class="title" style="display:none;">技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/technology/Git/" class="nav-link">Git</a></li><li class="dropdown-item"><!----> <a href="/technology/Linux/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/pages/b5d182/" class="nav-link">正则表达式</a></li></ul></div></div><div class="nav-item"><a href="/pages/edb686/" aria-current="page" class="nav-link router-link-exact-active router-link-active">面试</a></div><div class="nav-item"><a href="/pages/2aa63b/" class="nav-link">项目记录</a></div><div class="nav-item"><a href="/pages/1b70fb/" class="nav-link">DOA</a></div><div class="nav-item"><a href="/pages/d591da/" class="nav-link">精彩瞬间</a></div><div class="nav-item"><a href="/pages/961a83/" class="nav-link">任意门</a></div><div class="nav-item"><a href="https://github.com/diana-devil/diana-devil.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/devil.jpg"> <div class="blogger-info"><h3>凉冰</h3> <span>奋勇向前的可爱小恶魔！</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">主页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="后端" class="dropdown-title"><a href="/Java-C/" class="link-title">后端</a> <span class="title" style="display:none;">后端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/back/java/" class="nav-link">Java</a></li><li class="dropdown-item"><!----> <a href="/back/javaWeb/" class="nav-link">JavaWeb</a></li><li class="dropdown-item"><!----> <a href="/back/sql/" class="nav-link">数据库</a></li><li class="dropdown-item"><!----> <a href="/back/SSM/" class="nav-link">SSM</a></li><li class="dropdown-item"><!----> <a href="/back/SpringBoot/" class="nav-link">SpringBoot</a></li><li class="dropdown-item"><!----> <a href="/back/Microservice/" class="nav-link">微服务</a></li></ul></div></div><div class="nav-item"><a href="/Algorithm/" class="nav-link">算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><a href="/technology/" class="link-title">技术</a> <span class="title" style="display:none;">技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/technology/Git/" class="nav-link">Git</a></li><li class="dropdown-item"><!----> <a href="/technology/Linux/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/pages/b5d182/" class="nav-link">正则表达式</a></li></ul></div></div><div class="nav-item"><a href="/pages/edb686/" aria-current="page" class="nav-link router-link-exact-active router-link-active">面试</a></div><div class="nav-item"><a href="/pages/2aa63b/" class="nav-link">项目记录</a></div><div class="nav-item"><a href="/pages/1b70fb/" class="nav-link">DOA</a></div><div class="nav-item"><a href="/pages/d591da/" class="nav-link">精彩瞬间</a></div><div class="nav-item"><a href="/pages/961a83/" class="nav-link">任意门</a></div><div class="nav-item"><a href="https://github.com/diana-devil/diana-devil.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/pages/edb686/" aria-current="page" class="active sidebar-link">Redis篇</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/edb686/#redis与memcache的区别" class="sidebar-link">Redis与Memcache的区别？</a></li><li class="sidebar-sub-header level2"><a href="/pages/edb686/#redis的单线程问题" class="sidebar-link">Redis的单线程问题</a></li><li class="sidebar-sub-header level2"><a href="/pages/edb686/#redis的持久化方案由哪些" class="sidebar-link">Redis的持久化方案由哪些？</a></li><li class="sidebar-sub-header level2"><a href="/pages/edb686/#redis的集群方式有哪些" class="sidebar-link">Redis的集群方式有哪些？</a></li><li class="sidebar-sub-header level2"><a href="/pages/edb686/#redis的常用数据类型有哪些" class="sidebar-link">Redis的常用数据类型有哪些？</a></li><li class="sidebar-sub-header level2"><a href="/pages/edb686/#聊一下redis事务机制" class="sidebar-link">聊一下Redis事务机制</a></li><li class="sidebar-sub-header level2"><a href="/pages/edb686/#redis的key过期策略" class="sidebar-link">Redis的Key过期策略</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/edb686/#参考资料" class="sidebar-link">参考资料：</a></li><li class="sidebar-sub-header level3"><a href="/pages/edb686/#面试话术" class="sidebar-link">面试话术：</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/edb686/#redis在项目中的哪些地方有用到" class="sidebar-link">Redis在项目中的哪些地方有用到?</a></li><li class="sidebar-sub-header level2"><a href="/pages/edb686/#redis的缓存击穿、缓存雪崩、缓存穿透" class="sidebar-link">Redis的缓存击穿、缓存雪崩、缓存穿透</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/edb686/#_1-缓存穿透" class="sidebar-link">1）缓存穿透</a></li><li class="sidebar-sub-header level3"><a href="/pages/edb686/#_2-缓存击穿" class="sidebar-link">2）缓存击穿</a></li><li class="sidebar-sub-header level3"><a href="/pages/edb686/#_3-缓存雪崩" class="sidebar-link">3）缓存雪崩</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/edb686/#缓存冷热数据分离" class="sidebar-link">缓存冷热数据分离</a></li><li class="sidebar-sub-header level2"><a href="/pages/edb686/#redis实现分布式锁" class="sidebar-link">Redis实现分布式锁</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/edb686/#_1-最基本的分布式锁" class="sidebar-link">1）最基本的分布式锁：</a></li><li class="sidebar-sub-header level3"><a href="/pages/edb686/#_2-可重入分布式锁" class="sidebar-link">2）可重入分布式锁</a></li><li class="sidebar-sub-header level3"><a href="/pages/edb686/#_3-高可用的锁" class="sidebar-link">3）高可用的锁</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/edb686/#如何实现数据库与缓存数据一致" class="sidebar-link">如何实现数据库与缓存数据一致？</a></li></ul></li><li><a href="/pages/fa00f8/" class="sidebar-link">微服务篇</a></li><li><a href="/pages/8b5a99/" class="sidebar-link">MQ相关</a></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/categories/?category=%E9%9D%A2%E8%AF%95" title="分类" data-v-06225672>面试</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/diana-devil" target="_blank" title="作者" class="beLink" data-v-06225672>凉冰</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-06-30</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">Redis篇<!----></h1> <!----> <div class="theme-vdoing-content content__default"><h2 id="redis与memcache的区别"><a href="#redis与memcache的区别" class="header-anchor">#</a> Redis与Memcache的区别？</h2> <ul><li><code>redis支持更丰富的数据类型</code>（支持更复杂的应用场景）：Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。</li> <li><code>Redis支持数据的持久化</code>，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中。</li> <li><code>集群模式</code>：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的.</li> <li><code>Redis使用单线程</code>：Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型。</li></ul> <p><img src="/assets/%E9%9D%A2%E8%AF%95/Redis/1574821356723.png" alt="1574821356723"></p> <h2 id="redis的单线程问题"><a href="#redis的单线程问题" class="header-anchor">#</a> Redis的单线程问题</h2> <p><strong>面试官</strong>：Redis采用单线程，如何保证高并发？</p> <p><strong>面试话术</strong>：</p> <p>Redis快的主要原因是：</p> <ol><li>完全基于内存</li> <li>数据结构简单，对数据操作也简单</li> <li>使用多路 I/O 复用模型，充分利用CPU资源</li></ol> <p><strong>面试官</strong>：这样做的好处是什么？</p> <p><strong>面试话术</strong>：</p> <p>单线程优势有下面几点：</p> <ul><li>代码更清晰，处理逻辑更简单</li> <li>不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为锁而导致的性能消耗</li> <li>不存在多进程或者多线程导致的CPU切换，充分利用CPU资源</li></ul> <h2 id="redis的持久化方案由哪些"><a href="#redis的持久化方案由哪些" class="header-anchor">#</a> Redis的持久化方案由哪些？</h2> <p><strong>相关资料：</strong></p> <p>1）RDB 持久化</p> <p>RDB持久化可以使用save或bgsave，为了不阻塞主进程业务，一般都使用bgsave，流程：</p> <ul><li>Redis 进程会 fork 出一个子进程（与父进程内存数据一致）。</li> <li>父进程继续处理客户端请求命令</li> <li>由子进程将内存中的所有数据写入到一个临时的 RDB 文件中。</li> <li>完成写入操作之后，旧的 RDB 文件会被新的 RDB 文件替换掉。</li></ul> <p>下面是一些和 RDB 持久化相关的配置：</p> <ul><li><code>save 60 10000</code>：如果在 60 秒内有 10000 个 key 发生改变，那就执行 RDB 持久化。</li> <li><code>stop-writes-on-bgsave-error yes</code>：如果 Redis 执行 RDB 持久化失败（常见于操作系统内存不足），那么 Redis 将不再接受 client 写入数据的请求。</li> <li><code>rdbcompression yes</code>：当生成 RDB 文件时，同时进行压缩。</li> <li><code>dbfilename dump.rdb</code>：将 RDB 文件命名为 dump.rdb。</li> <li><code>dir /var/lib/redis</code>：将 RDB 文件保存在<code>/var/lib/redis</code>目录下。</li></ul> <p>当然在实践中，我们通常会将<code>stop-writes-on-bgsave-error</code>设置为<code>false</code>，同时让监控系统在 Redis 执行 RDB 持久化失败时发送告警，以便人工介入解决，而不是粗暴地拒绝 client 的写入请求。</p> <p>RDB持久化的优点：</p> <ul><li>RDB持久化文件小，Redis数据恢复时速度快</li> <li>子进程不影响父进程，父进程可以持续处理客户端命令</li> <li>子进程fork时采用copy-on-write方式，大多数情况下，没有太多的内存消耗，效率比较好。</li></ul> <p>RDB 持久化的缺点：</p> <ul><li>子进程fork时采用copy-on-write方式，如果Redis此时写操作较多，可能导致额外的内存占用，甚至内存溢出</li> <li>RDB文件压缩会减小文件体积，但通过时会对CPU有额外的消耗</li> <li>如果业务场景很看重数据的持久性 (durability)，那么不应该采用 RDB 持久化。譬如说，如果 Redis 每 5 分钟执行一次 RDB 持久化，要是 Redis 意外奔溃了，那么最多会丢失 5 分钟的数据。</li></ul> <p>2）AOF 持久化</p> <p>可以使用<code>appendonly yes</code>配置项来开启 AOF 持久化。Redis 执行 AOF 持久化时，会将接收到的写命令追加到 AOF 文件的末尾，因此 Redis 只要对 AOF 文件中的命令进行回放，就可以将数据库还原到原先的状态。
　　与 RDB 持久化相比，AOF 持久化的一个明显优势就是，它可以提高数据的持久性 (durability)。因为在 AOF 模式下，Redis 每次接收到 client 的写命令，就会将命令<code>write()</code>到 AOF 文件末尾。
　　然而，在 Linux 中，将数据<code>write()</code>到文件后，数据并不会立即刷新到磁盘，而会先暂存在 OS 的文件系统缓冲区。在合适的时机，OS 才会将缓冲区的数据刷新到磁盘（如果需要将文件内容刷新到磁盘，可以调用<code>fsync()</code>或<code>fdatasync()</code>）。
　　通过<code>appendfsync</code>配置项，可以控制 Redis 将命令同步到磁盘的频率：</p> <ul><li><code>always</code>：每次 Redis 将命令<code>write()</code>到 AOF 文件时，都会调用<code>fsync()</code>，将命令刷新到磁盘。这可以保证最好的数据持久性，但却会给系统带来极大的开销。</li> <li><code>no</code>：Redis 只将命令<code>write()</code>到 AOF 文件。这会让 OS 决定何时将命令刷新到磁盘。</li> <li><code>everysec</code>：除了将命令<code>write()</code>到 AOF 文件，Redis 还会每秒执行一次<code>fsync()</code>。在实践中，推荐使用这种设置，一定程度上可以保证数据持久性，又不会明显降低 Redis 性能。</li></ul> <p>然而，AOF 持久化并不是没有缺点的：Redis 会不断将接收到的写命令追加到 AOF 文件中，导致 AOF 文件越来越大。过大的 AOF 文件会消耗磁盘空间，并且导致 Redis 重启时更加缓慢。为了解决这个问题，在适当情况下，Redis 会对 AOF 文件进行重写，去除文件中冗余的命令，以减小 AOF 文件的体积。在重写 AOF 文件期间， Redis 会启动一个子进程，由子进程负责对 AOF 文件进行重写。
　　可以通过下面两个配置项，控制 Redis 重写 AOF 文件的频率：</p> <ul><li><code>auto-aof-rewrite-min-size 64mb</code></li> <li><code>auto-aof-rewrite-percentage 100</code></li></ul> <p>上面两个配置的作用：当 AOF 文件的体积大于 64MB，并且 AOF 文件的体积比上一次重写之后的体积大了至少一倍，那么 Redis 就会执行 AOF 重写。</p> <p>优点：</p> <ul><li>持久化频率高，数据可靠性高</li> <li>没有额外的内存或CPU消耗</li></ul> <p>缺点：</p> <ul><li>文件体积大</li> <li>文件大导致服务数据恢复时效率较低</li></ul> <p><strong>面试话术：</strong></p> <p>Redis 提供了两种数据持久化的方式，一种是 RDB，另一种是 AOF。默认情况下，Redis 使用的是 RDB 持久化。</p> <p>RDB持久化文件体积较小，但是保存数据的频率一般较低，可靠性差，容易丢失数据。另外RDB写数据时会采用Fork函数拷贝主进程，可能有额外的内存消耗，文件压缩也会有额外的CPU消耗。</p> <p>ROF持久化可以做到每秒钟持久化一次，可靠性高。但是持久化文件体积较大，导致数据恢复时读取文件时间较长，效率略低</p> <h2 id="redis的集群方式有哪些"><a href="#redis的集群方式有哪些" class="header-anchor">#</a> Redis的集群方式有哪些？</h2> <p><strong>面试话术：</strong></p> <p>Redis集群可以分为<strong>主从集群</strong>和<strong>分片集群</strong>两类。</p> <p><strong>主从集群</strong>一般一主多从，主库用来写数据，从库用来读数据。结合哨兵，可以再主库宕机时从新选主，<strong>目的是保证Redis的高可用</strong>。</p> <p><strong>分片集群</strong>是数据分片，我们会让多个Redis节点组成集群，并将16383个插槽分到不同的节点上。存储数据时利用对key做hash运算，得到插槽值后存储到对应的节点即可。因为存储数据面向的是插槽而非节点本身，因此可以做到集群动态伸缩。<strong>目的是让Redis能存储更多数据。</strong></p> <p>1）主从集群</p> <p>主从集群，也是读写分离集群。一般都是一主多从方式。</p> <p>Redis 的复制（replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器（master），而通过复制创建出来的服务器复制品则为从服务器（slave）。</p> <p>只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，主服务器就会一直将发生在自己身上的数据更新同步 给从服务器，从而一直保证主从服务器的数据相同。</p> <ul><li>写数据时只能通过主节点完成</li> <li>读数据可以从任何节点完成</li> <li>如果配置了<code>哨兵节点</code>，当master宕机时，哨兵会从salve节点选出一个新的主。</li></ul> <p>主从集群分两种：</p> <p><img src="/assets/%E9%9D%A2%E8%AF%95/Redis/1574821993599.png" alt="1574821993599"> <img src="/assets/%E9%9D%A2%E8%AF%95/Redis/1574822026037.png" alt="1574822026037"></p> <p>带有哨兵的集群：</p> <p><img src="/assets/%E9%9D%A2%E8%AF%95/Redis/1574822077190.png" alt="1574822077190"></p> <p>2）分片集群</p> <p>主从集群中，每个节点都要保存所有信息，容易形成木桶效应。并且当数据量较大时，单个机器无法满足需求。此时我们就要使用分片集群了。</p> <p><img src="/assets/%E9%9D%A2%E8%AF%95/Redis/1574822184467.png" alt="1574822184467"></p> <p>集群特征：</p> <ul><li><p>每个节点都保存不同数据</p></li> <li><p>所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.</p></li> <li><p>节点的fail是通过集群中超过半数的节点检测失效时才生效.</p></li> <li><p>客户端与redis节点直连,不需要中间proxy层连接集群中任何一个可用节点都可以访问到数据</p></li> <li><p>redis-cluster把所有的物理节点映射到[0-16383]slot（插槽）上，实现动态伸缩</p></li></ul> <p>为了保证Redis中每个节点的高可用，我们还可以给每个节点创建replication（slave节点），如图：</p> <p><img src="/assets/%E9%9D%A2%E8%AF%95/Redis/1574822584357.png" alt="1574822584357"></p> <p>出现故障时，主从可以及时切换：</p> <p><img src="/assets/%E9%9D%A2%E8%AF%95/Redis/1574822602109.png" alt="1574822602109"></p> <h2 id="redis的常用数据类型有哪些"><a href="#redis的常用数据类型有哪些" class="header-anchor">#</a> Redis的常用数据类型有哪些？</h2> <p>支持多种类型的数据结构，主要区别是value存储的数据格式不同：</p> <ul><li><p>string：最基本的数据类型，二进制安全的字符串，最大512M。</p></li> <li><p>list：按照添加顺序保持顺序的字符串列表。</p></li> <li><p>set：无序的字符串集合，不存在重复的元素。</p></li> <li><p>sorted set：已排序的字符串集合。</p></li> <li><p>hash：key-value对格式</p></li></ul> <h2 id="聊一下redis事务机制"><a href="#聊一下redis事务机制" class="header-anchor">#</a> 聊一下Redis事务机制</h2> <p><strong>相关资料：</strong></p> <p>参考：http://redisdoc.com/topic/transaction.html</p> <p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的。Redis会将一个事务中的所有命令序列化，然后按顺序执行。但是Redis事务不支持回滚操作，命令运行出错后，正确的命令会继续执行。</p> <ul><li><code>MULTI</code>: 用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个<strong>待执行命令队列</strong>中</li> <li><code>EXEC</code>：按顺序执行命令队列内的所有命令。返回所有命令的返回值。事务执行过程中，Redis不会执行其它事务的命令。</li> <li><code>DISCARD</code>：清空命令队列，并放弃执行事务， 并且客户端会从事务状态中退出</li> <li><code>WATCH</code>：Redis的乐观锁机制，利用compare-and-set（CAS）原理，可以监控一个或多个键，一旦其中有一个键被修改，之后的事务就不会执行</li></ul> <p>使用事务时可能会遇上以下两种错误：</p> <ul><li>执行 EXEC 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误，等等），或者其他更严重的错误，比如内存不足（如果服务器使用 <code>maxmemory</code> 设置了最大内存限制的话）。
<ul><li>Redis 2.6.5 开始，服务器会对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务。</li></ul></li> <li>命令可能在 EXEC 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。
<ul><li>即使事务中有某个/某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行，不会回滚。</li></ul></li></ul> <p>为什么 Redis 不支持回滚（roll back）？</p> <p>以下是这种做法的优点：</p> <ul><li>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由<strong>编程错误</strong>造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</li> <li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li></ul> <p>鉴于没有任何机制能避免程序员自己造成的错误， 并且这类错误通常不会在生产环境中出现， 所以 Redis 选择了更简单、更快速的无回滚方式来处理事务。</p> <p><strong>面试话术：</strong></p> <p>Redis事务其实是把一系列Redis命令放入队列，然后批量执行，执行过程中不会有其它事务来打断。不过与关系型数据库的事务不同，Redis事务不支持回滚操作，事务中某个命令执行失败，其它命令依然会执行。</p> <p>为了弥补不能回滚的问题，Redis会在事务入队时就检查命令，如果命令异常则会放弃整个事务。</p> <p>因此，只要程序员编程是正确的，理论上说Redis会正确执行所有事务，无需回滚。</p> <p>面试官：如果事务执行一半的时候Redis宕机怎么办？</p> <p>Redis有持久化机制，因为可靠性问题，我们一般使用AOF持久化。事务的所有命令也会写入AOF文件，但是如果在执行EXEC命令之前，Redis已经宕机，则AOF文件中事务不完整。使用 <code>redis-check-aof</code> 程序可以移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。</p> <h2 id="redis的key过期策略"><a href="#redis的key过期策略" class="header-anchor">#</a> Redis的Key过期策略</h2> <h3 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> <strong>参考资料：</strong></h3> <h4 id="为什么需要内存回收"><a href="#为什么需要内存回收" class="header-anchor">#</a> 为什么需要内存回收？</h4> <ul><li>1、在Redis中，set指令可以指定key的过期时间，当过期时间到达以后，key就失效了；</li> <li>2、Redis是基于内存操作的，所有的数据都是保存在内存中，一台机器的内存是有限且很宝贵的。</li></ul> <p>基于以上两点，为了保证Redis能继续提供可靠的服务，Redis需要一种机制清理掉不常用的、无效的、多余的数据，失效后的数据需要及时清理，这就需要内存回收了。</p> <p>Redis的内存回收主要分为过期删除策略和内存淘汰策略两部分。</p> <h4 id="过期删除策略"><a href="#过期删除策略" class="header-anchor">#</a> 过期删除策略</h4> <p>删除达到过期时间的key。</p> <ul><li>1）定时删除</li></ul> <p>对于每一个设置了过期时间的key都会创建一个定时器，一旦到达过期时间就立即删除。该策略可以立即清除过期的数据，对内存较友好，但是缺点是占用了大量的CPU资源去处理过期的数据，会影响Redis的吞吐量和响应时间。</p> <ul><li>2）惰性删除</li></ul> <p>当访问一个key时，才判断该key是否过期，过期则删除。该策略能最大限度地节省CPU资源，但是对内存却十分不友好。有一种极端的情况是可能出现大量的过期key没有被再次访问，因此不会被清除，导致占用了大量的内存。</p> <blockquote><p>在计算机科学中，懒惰删除（英文：lazy deletion）指的是从一个散列表（也称哈希表）中删除元素的一种方法。在这个方法中，删除仅仅是指标记一个元素被删除，而不是整个清除它。被删除的位点在插入时被当作空元素，在搜索之时被当作已占据。</p></blockquote> <ul><li>3）定期删除</li></ul> <p>每隔一段时间，扫描Redis中过期key字典，并清除部分过期的key。该策略是前两者的一个折中方案，还可以通过调整定时扫描的时间间隔和每次扫描的限定耗时，在不同情况下使得CPU和内存资源达到最优的平衡效果。</p> <p>在Redis中，<code>同时使用了定期删除和惰性删除</code>。不过Redis定期删除采用的是随机抽取的方式删除部分Key，因此不能保证过期key 100%的删除。</p> <p>Redis结合了定期删除和惰性删除，基本上能很好的处理过期数据的清理，但是实际上还是有点问题的，如果过期key较多，定期删除漏掉了一部分，而且也没有及时去查，即没有走惰性删除，那么就会有大量的过期key堆积在内存中，导致redis内存耗尽，当内存耗尽之后，有新的key到来会发生什么事呢？是直接抛弃还是其他措施呢？有什么办法可以接受更多的key？</p> <h4 id="内存淘汰策略"><a href="#内存淘汰策略" class="header-anchor">#</a> 内存淘汰策略</h4> <p>Redis的内存淘汰策略，是指内存达到maxmemory极限时，使用某种算法来决定清理掉哪些数据，以保证新数据的存入。</p> <p>Redis的内存淘汰机制包括：</p> <ul><li>noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错。</li> <li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间（<code>server.db[i].dict</code>）中，移除最近最少使用的 key（这个是最常用的）。</li> <li>allkeys-random：当内存不足以容纳新写入数据时，在键空间（<code>server.db[i].dict</code>）中，随机移除某个 key。</li> <li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间（<code>server.db[i].expires</code>）中，移除最近最少使用的 key。</li> <li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间（<code>server.db[i].expires</code>）中，随机移除某个 key。</li> <li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间（<code>server.db[i].expires</code>）中，有更早过期时间的 key 优先移除。</li></ul> <blockquote><p>在配置文件中，通过maxmemory-policy可以配置要使用哪一个淘汰机制。</p></blockquote> <p>什么时候会进行淘汰？</p> <p>Redis会在每一次处理命令的时候（processCommand函数调用freeMemoryIfNeeded）判断当前redis是否达到了内存的最大限制，如果达到限制，则使用对应的算法去处理需要删除的key。</p> <p>在淘汰key时，Redis默认最常用的是LRU算法（Latest Recently Used）。Redis通过在每一个redisObject保存lru属性来保存key最近的访问时间，在实现LRU算法时直接读取key的lru属性。</p> <p>具体实现时，Redis遍历每一个db，从每一个db中随机抽取一批样本key，默认是3个key，再从这3个key中，删除最近最少使用的key。</p> <h3 id="面试话术"><a href="#面试话术" class="header-anchor">#</a> 面试话术：</h3> <p>Redis过期策略包含定期删除和惰性删除两部分。定期删除是在Redis内部有一个定时任务，会定期删除一些过期的key。惰性删除是当用户查询某个Key时，会检查这个Key是否已经过期，如果没过期则返回用户，如果过期则删除。</p> <p>但是这两个策略都无法保证过期key一定删除，漏网之鱼越来越多，还可能导致内存溢出。当发生内存不足问题时，Redis还会做内存回收。内存回收采用LRU策略，就是最近最少使用。其原理就是记录每个Key的最近使用时间，内存回收时，随机抽取一些Key，比较其使用时间，把最老的几个删除。</p> <p>Redis的逻辑是：最近使用过的，很可能再次被使用</p> <h2 id="redis在项目中的哪些地方有用到"><a href="#redis在项目中的哪些地方有用到" class="header-anchor">#</a> Redis在项目中的哪些地方有用到?</h2> <p>（1）共享session</p> <p>在分布式系统下，服务会部署在不同的tomcat，因此多个tomcat的session无法共享，以前存储在session中的数据无法实现共享，可以用redis代替session，解决分布式系统间数据共享问题。</p> <p>（2）数据缓存</p> <p>Redis采用内存存储，读写效率较高。我们可以把数据库的访问频率高的热点数据存储到redis中，这样用户请求时优先从redis中读取，减少数据库压力，提高并发能力。</p> <p>（3）异步队列</p> <p>Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。而且Redis中还有pub/sub这样的专用结构，用于1对N的消息通信模式。</p> <p>（4）分布式锁</p> <p>Redis中的乐观锁机制，可以帮助我们实现分布式锁的效果，用于解决分布式系统下的多线程安全问题</p> <h2 id="redis的缓存击穿、缓存雪崩、缓存穿透"><a href="#redis的缓存击穿、缓存雪崩、缓存穿透" class="header-anchor">#</a> Redis的缓存击穿、缓存雪崩、缓存穿透</h2> <h3 id="_1-缓存穿透"><a href="#_1-缓存穿透" class="header-anchor">#</a> 1）缓存穿透</h3> <p>参考资料：</p> <ul><li><p>什么是缓存穿透</p> <ul><li>正常情况下，我们去查询数据都是存在。那么请求去查询一条压根儿数据库中根本就不存在的数据，也就是缓存和数据库都查询不到这条数据，但是请求每次都会打到数据库上面去。这种查询不存在数据的现象我们称为<strong>缓存穿透</strong>。</li></ul></li> <li><p>穿透带来的问题</p> <ul><li>试想一下，如果有黑客会对你的系统进行攻击，拿一个不存在的id 去查询数据，会产生大量的请求到数据库去查询。可能会导致你的数据库由于压力过大而宕掉。</li></ul></li> <li><p>解决办法</p> <ul><li>缓存空值：之所以会发生穿透，就是因为缓存中没有存储这些空数据的key。从而导致每次查询都到数据库去了。那么我们就可以为这些key对应的值设置为null 丢到缓存里面去。后面再出现查询这个key 的请求的时候，直接返回null 。这样，就不用在到数据库中去走一圈了，但是别忘了设置过期时间。</li> <li>BloomFilter（布隆过滤）：将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。在缓存之前在加一层 BloomFilter ，在查询的时候先去 BloomFilter 去查询 key 是否存在，如果不存在就直接返回，存在再走查缓存 -&gt; 查 DB。</li></ul></li></ul> <p><strong>话术：</strong></p> <p>缓存穿透有两种解决方案：<strong>其一</strong>是把不存在的key设置null值到缓存中。<strong>其二</strong>是使用布隆过滤器，在查询缓存前先通过布隆过滤器判断key是否存在，存在再去查询缓存。</p> <p>设置null值可能被恶意针对，攻击者使用大量不存在的不重复key ，那么方案一就会缓存大量不存在key数据。此时我们还可以对Key规定格式模板，然后对不存在的key做<strong>正则规范</strong>匹配，如果完全不符合就不用存null值到redis，而是直接返回错误。</p> <h3 id="_2-缓存击穿"><a href="#_2-缓存击穿" class="header-anchor">#</a> 2）缓存击穿</h3> <p><strong>相关资料</strong>：</p> <ul><li>什么是缓存击穿？</li></ul> <p>key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。</p> <p>当这个key在失效的瞬间，redis查询失败，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p> <ul><li>解决方案：
<ul><li>使用互斥锁(mutex key)：mutex，就是互斥。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用Redis的SETNX去set一个互斥key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。SETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现互斥的效果。</li> <li>软过期：也就是逻辑过期，不使用redis提供的过期时间，而是业务层在数据中存储过期时间信息。查询时由业务程序判断是否过期，如果数据即将过期时，将缓存的时效延长，程序可以派遣一个线程去数据库中获取最新的数据，其他线程这时看到延长了的过期时间，就会继续使用旧数据，等派遣的线程获取最新数据后再更新缓存。</li></ul></li></ul> <p>推荐使用互斥锁，因为软过期会有业务逻辑侵入和额外的判断。</p> <p><strong>面试话术</strong>：</p> <p>缓存击穿主要担心的是某个Key过期，更新缓存时引起对数据库的突发高并发访问。因此我们可以在更新缓存时采用互斥锁控制，只允许一个线程去更新缓存，其它线程等待并重新读取缓存。例如Redis的setnx命令就能实现互斥效果。</p> <h3 id="_3-缓存雪崩"><a href="#_3-缓存雪崩" class="header-anchor">#</a> 3）缓存雪崩</h3> <p><strong>相关资料</strong>：</p> <p>缓存雪崩，是指在某一个时间段，缓存集中过期失效。对这批数据的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。</p> <p>解决方案：</p> <ul><li>数据分类分批处理：采取不同分类数据，缓存不同周期</li> <li>相同分类数据：采用固定时长加随机数方式设置缓存</li> <li>热点数据缓存时间长一些，冷门数据缓存时间短一些</li> <li>避免redis节点宕机引起雪崩，搭建主从集群，保证高可用</li></ul> <p><strong>面试话术：</strong></p> <p>解决缓存雪崩问题的关键是让缓存Key的过期时间分散。因此我们可以把数据按照业务分类，然后设置不同过期时间。相同业务类型的key，设置固定时长加随机数。尽可能保证每个Key的过期时间都不相同。</p> <p>另外，Redis宕机也可能导致缓存雪崩，因此我们还要搭建Redis主从集群及哨兵监控，保证Redis的高可用。</p> <h2 id="缓存冷热数据分离"><a href="#缓存冷热数据分离" class="header-anchor">#</a> 缓存冷热数据分离</h2> <p><strong>背景资料</strong>：</p> <p>Redis使用的是内存存储，当需要海量数据存储时，成本非常高。</p> <p>经过调研发现，当前主流DDR3内存和主流SATA SSD的单位成本价格差距大概在20倍左右，为了优化redis机器综合成本，我们考虑实现基于<strong>热度统计 的数据分级存储</strong>及数据在RAM/FLASH之间的动态交换，从而大幅度降低成本，达到性能与成本的高平衡。</p> <p>基本思路：基于key访问次数(LFU)的热度统计算法识别出热点数据，并将热点数据保留在redis中，对于无访问/访问次数少的数据则转存到SSD上，如果SSD上的key再次变热，则重新将其加载到redis内存中。</p> <p>目前流行的高性能磁盘存储，并且遵循Redis协议的方案包括：</p> <ul><li>SSDB：http://ssdb.io/zh_cn/</li> <li>RocksDB：https://rocksdb.org.cn/</li></ul> <p>因此，我们就需要在应用程序与缓存服务之间引入代理，实现Redis和SSD之间的切换，如图：</p> <p><img src="/assets/%E9%9D%A2%E8%AF%95/Redis/image-20200521115702956.png" alt="image-20200521115702956"></p> <p>这样的代理方案阿里云提供的就有。当然也有一些开源方案，例如：https://github.com/JingchengLi/swapdb</p> <h2 id="redis实现分布式锁"><a href="#redis实现分布式锁" class="header-anchor">#</a> Redis实现分布式锁</h2> <p>分布式锁要满足的条件：</p> <ul><li>多进程互斥：同一时刻，只有一个进程可以获取锁</li> <li>保证锁可以释放：任务结束或出现异常，锁一定要释放，避免死锁</li> <li>阻塞锁（可选）：获取锁失败时可否重试</li> <li>重入锁（可选）：获取锁的代码递归调用时，依然可以获取锁</li></ul> <h3 id="_1-最基本的分布式锁"><a href="#_1-最基本的分布式锁" class="header-anchor">#</a> 1）最基本的分布式锁：</h3> <p>利用Redis的setnx命令，这个命令的特征时如果多次执行，只有第一次执行会成功，可以实现<code>互斥</code>的效果。但是为了保证服务宕机时也可以释放锁，需要利用expire命令给锁设置一个有效期</p> <div class="language- extra-class"><pre class="language-text"><code>setnx lock thread-01 # 尝试获取锁
expire lock 10 # 设置有效期
</code></pre></div><p><strong>面试官问题1</strong>：如果expire之前服务宕机怎么办？</p> <p>要保证setnx和expire命令的原子性。redis的set命令可以满足：</p> <div class="language- extra-class"><pre class="language-text"><code>set key value [NX] [EX time] 
</code></pre></div><p>需要添加nx和ex的选项：</p> <ul><li>NX：与setnx一致，第一次执行成功</li> <li>EX：设置过期时间</li></ul> <p><strong>面试官问题2</strong>：释放锁的时候，如果自己的锁已经过期了，此时会出现安全漏洞，如何解决？</p> <p>在锁中存储当前进程和线程标识，释放锁时对锁的标识判断，如果是自己的则删除，不是则放弃操作。</p> <p>但是这两步操作要保证原子性，需要通过Lua脚本来实现。</p> <div class="language- extra-class"><pre class="language-text"><code>if redis.call(&quot;get&quot;,KEYS[1]) ** ARGV[1] then
    redis.call(&quot;del&quot;,KEYS[1])
end
</code></pre></div><h3 id="_2-可重入分布式锁"><a href="#_2-可重入分布式锁" class="header-anchor">#</a> 2）可重入分布式锁</h3> <p>如果有重入的需求，则除了在锁中记录进程标识，还要记录重试次数，流程如下：</p> <p><img src="/assets/%E9%9D%A2%E8%AF%95/Redis/1574824172228.png" alt="1574824172228"></p> <p>下面我们假设锁的key为“<code>lock</code>”，hashKey是当前线程的id：“<code>threadId</code>”，锁自动释放时间假设为20</p> <p>获取锁的步骤：</p> <ul><li>1、判断lock是否存在 <code>EXISTS lock</code> <ul><li>存在，说明有人获取锁了，下面判断是不是自己的锁
<ul><li>判断当前线程id作为hashKey是否存在：<code>HEXISTS lock threadId</code> <ul><li>不存在，说明锁已经有了，且不是自己获取的，锁获取失败，end</li> <li>存在，说明是自己获取的锁，重入次数+1：<code>HINCRBY lock threadId 1</code>，去到步骤3</li></ul></li></ul></li> <li>2、不存在，说明可以获取锁，<code>HSET key threadId 1</code></li> <li>3、设置锁自动释放时间，<code>EXPIRE lock 20</code></li></ul></li></ul> <p>释放锁的步骤：</p> <ul><li>1、判断当前线程id作为hashKey是否存在：<code>HEXISTS lock threadId</code> <ul><li>不存在，说明锁已经失效，不用管了</li> <li>存在，说明锁还在，重入次数减1：<code>HINCRBY lock threadId -1</code>，获取新的重入次数</li></ul></li> <li>2、判断重入次数是否为0：
<ul><li>为0，说明锁全部释放，删除key：<code>DEL lock</code></li> <li>大于0，说明锁还在使用，重置有效时间：<code>EXPIRE lock 20</code></li></ul></li></ul> <p>对应的Lua脚本如下：</p> <p>首先是获取锁：</p> <div class="language-lua extra-class"><pre class="language-lua"><code><span class="token keyword">local</span> key <span class="token operator">=</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">-- 锁的key</span>
<span class="token keyword">local</span> threadId <span class="token operator">=</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">-- 线程唯一标识</span>
<span class="token keyword">local</span> releaseTime <span class="token operator">=</span> ARGV<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">-- 锁的自动释放时间</span>

<span class="token keyword">if</span><span class="token punctuation">(</span>redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'exists'</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token operator">*</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">then</span> <span class="token comment">-- 判断是否存在</span>
	redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'hset'</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> threadId<span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- 不存在, 获取锁</span>
	redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'expire'</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> releaseTime<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- 设置有效期</span>
	<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">-- 返回结果</span>
<span class="token keyword">end</span><span class="token punctuation">;</span>

<span class="token keyword">if</span><span class="token punctuation">(</span>redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'hexists'</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token operator">*</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">then</span> <span class="token comment">-- 锁已经存在，判断threadId是否是自己	</span>
	redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'hincrby'</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> threadId<span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- 不存在, 获取锁，重入次数+1</span>
	redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'expire'</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> releaseTime<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- 设置有效期</span>
	<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">-- 返回结果</span>
<span class="token keyword">end</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">-- 代码走到这里,说明获取锁的不是自己，获取锁失败</span>
</code></pre></div><p>然后是释放锁：</p> <div class="language-lua extra-class"><pre class="language-lua"><code><span class="token keyword">local</span> key <span class="token operator">=</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">-- 锁的key</span>
<span class="token keyword">local</span> threadId <span class="token operator">=</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">-- 线程唯一标识</span>
<span class="token keyword">local</span> releaseTime <span class="token operator">=</span> ARGV<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">-- 锁的自动释放时间</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'HEXISTS'</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token operator">*</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">then</span> <span class="token comment">-- 判断当前锁是否还是被自己持有</span>
    <span class="token keyword">return</span> <span class="token keyword">nil</span><span class="token punctuation">;</span> <span class="token comment">-- 如果已经不是自己，则直接返回</span>
<span class="token keyword">end</span><span class="token punctuation">;</span>
<span class="token keyword">local</span> count <span class="token operator">=</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'HINCRBY'</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> threadId<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- 是自己的锁，则重入次数-1</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">then</span> <span class="token comment">-- 判断是否重入次数是否已经为0</span>
    redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'EXPIRE'</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> releaseTime<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- 大于0说明不能释放锁，重置有效期然后返回</span>
    <span class="token keyword">return</span> <span class="token keyword">nil</span><span class="token punctuation">;</span>
<span class="token keyword">else</span>
    redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'DEL'</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- 等于0说明可以释放锁，直接删除</span>
    <span class="token keyword">return</span> <span class="token keyword">nil</span><span class="token punctuation">;</span>
<span class="token keyword">end</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="_3-高可用的锁"><a href="#_3-高可用的锁" class="header-anchor">#</a> 3）高可用的锁</h3> <p><code>面试官问题</code>：redis分布式锁依赖与redis，如果redis宕机则锁失效。如何解决？</p> <p>此时大多数同学会回答说：搭建主从集群，做数据备份。</p> <p>这样就进入了陷阱，因为面试官的下一个问题就来了：</p> <p><code>面试官问题</code>：如果搭建主从集群做数据备份时，进程A获取锁，master还没有把数据备份到slave，master宕机，slave升级为master，此时原来锁失效，其它进程也可以获取锁，出现安全问题。如何解决？</p> <p>关于这个问题，Redis官网给出了解决方案，使用RedLock思路可以解决：</p> <blockquote><p>在Redis的分布式环境中，我们假设有N个Redis master。这些节点完全互相独立，不存在主从复制或者其他集群协调机制。之前我们已经描述了在Redis单实例下怎么安全地获取和释放锁。我们确保将在每（N)个实例上使用此方法获取和释放锁。在这个样例中，我们假设有5个Redis master节点，这是一个比较合理的设置，所以我们需要在5台机器上面或者5台虚拟机上面运行这些实例，这样保证他们不会同时都宕掉。</p> <p>为了取到锁，客户端应该执行以下操作:</p> <ol><li>获取当前Unix时间，以毫秒为单位。</li> <li>依次尝试从N个实例，使用相同的key和随机值获取锁。在步骤2，当向Redis设置锁时,客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个Redis实例。</li> <li>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。当且仅当从大多数（这里是3个节点）的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。</li> <li>如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。</li> <li>如果因为某些原因，获取锁失败（<em>没有</em>在至少N/2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功）。</li></ol></blockquote> <h2 id="如何实现数据库与缓存数据一致"><a href="#如何实现数据库与缓存数据一致" class="header-anchor">#</a> 如何实现数据库与缓存数据一致？</h2> <p>面试话术：</p> <p>实现方案有下面几种：</p> <ul><li>本地缓存同步：当前微服务的数据库数据与缓存数据同步，可以直接在数据库修改时加入对Redis的修改逻辑，保证一致。</li> <li>跨服务缓存同步：服务A调用了服务B，并对查询结果缓存。服务B数据库修改，可以通过MQ通知服务A，服务A修改Redis缓存数据</li> <li>通用方案：使用Canal框架，伪装成MySQL的salve节点，监听MySQL的binLog变化，然后修改Redis缓存数据</li></ul></div></div> <!----> <div class="page-edit"><!----> <div class="tags"><a href="/tags/?tag=%E7%9F%A5%E8%AF%86" title="标签">#知识</a><a href="/tags/?tag=%E9%9D%A2%E8%AF%95" title="标签">#面试</a><a href="/tags/?tag=Redis" title="标签">#Redis</a></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2023 07 3</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><!----> <a href="/pages/fa00f8/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">微服务篇</div></a></div> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/pages/fa00f8/">微服务篇</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/0446de/"><div>
            数据层解决方案
            <!----></div></a> <span class="date">07-03</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/e76fff/"><div>
            第三方技术整合
            <!----></div></a> <span class="date">07-03</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/cd183e/"><div>
            原理篇
            <!----></div></a> <span class="date">07-03</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:1693849288@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/diana-devil" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://y.qq.com/n/ryqq/playlist/3202075040" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2023-2023
    <span>by 凉冰 </span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><!----><!----><canvas id="vuepress-canvas-cursor"></canvas><div class="reco-bgm-panel" data-v-b1d3339e><audio id="bgm" src="/bgm/G_E_M_ 邓紫棋 - FIND YOU.ogg" data-v-b1d3339e></audio> <div class="reco-float-box" style="bottom:200px;z-index:999999;display:none;" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><img src="/bgm/GEM.jpg" data-v-b1d3339e></div> <div class="reco-bgm-box" style="left:10px;bottom:10px;z-index:999999;" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><div class="reco-bgm-cover" style="background-image:url(/bgm/GEM.jpg);" data-v-b1d3339e><div class="mini-operation" style="display:none;" data-v-b1d3339e><i class="reco-bgm reco-bgm-pause" style="display:none;" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-play" style="display:none;" data-v-b1d3339e></i></div> <div class="falut-message" style="display:none;" data-v-b1d3339e>
          播放失败
        </div></div> <div class="reco-bgm-info" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><div class="info-box" data-v-b1d3339e><i class="reco-bgm reco-bgm-music music" data-v-b1d3339e></i>FIND YOU</div> <div class="info-box" data-v-b1d3339e><i class="reco-bgm reco-bgm-artist" data-v-b1d3339e></i>G_E_M_ 邓紫棋</div> <div class="reco-bgm-progress" data-v-b1d3339e><div class="progress-bar" data-v-b1d3339e><div class="bar" data-v-b1d3339e></div></div></div> <div class="reco-bgm-operation" data-v-b1d3339e><i class="reco-bgm reco-bgm-last last" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-pause pause" style="display:none;" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-play play" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-next next" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-volume1 volume" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-mute mute" style="display:none;" data-v-b1d3339e></i> <div class="volume-bar" data-v-b1d3339e><div class="bar" data-v-b1d3339e></div></div></div></div> <div class="reco-bgm-left-box" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><i class="reco-bgm reco-bgm-left" data-v-b1d3339e></i></div></div></div></div></div>
    <script src="/assets/js/app.3ee2b30c.js" defer></script><script src="/assets/js/2.fc657b59.js" defer></script><script src="/assets/js/145.3f68756b.js" defer></script><script src="/assets/js/3.e0ec9727.js" defer></script>
  </body>
</html>

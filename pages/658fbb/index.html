<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>字符串 | 凉冰的手记</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/favicon.ico">
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/icons/192.png">
    <link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#2196f3">
    <meta name="description" content="记录生活的精彩瞬间，记录一个程序猿的成长！">
    <meta name="keywords" content="琐事，小记">
    <meta name="author" href="凉冰">
    <meta name="theme-color" content="#2196f3">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/icons/144.png">
    <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/assets/css/0.styles.59ed400b.css" as="style"><link rel="preload" href="/assets/js/app.3ee2b30c.js" as="script"><link rel="preload" href="/assets/js/2.fc657b59.js" as="script"><link rel="preload" href="/assets/js/125.20627b3b.js" as="script"><link rel="preload" href="/assets/js/3.e0ec9727.js" as="script"><link rel="prefetch" href="/assets/js/10.eb4f1714.js"><link rel="prefetch" href="/assets/js/100.60572966.js"><link rel="prefetch" href="/assets/js/101.d94775a6.js"><link rel="prefetch" href="/assets/js/102.354c87f2.js"><link rel="prefetch" href="/assets/js/103.0322d8d3.js"><link rel="prefetch" href="/assets/js/104.330ce470.js"><link rel="prefetch" href="/assets/js/105.f2c0cf7b.js"><link rel="prefetch" href="/assets/js/106.9b15e481.js"><link rel="prefetch" href="/assets/js/107.f83846c8.js"><link rel="prefetch" href="/assets/js/108.fd868043.js"><link rel="prefetch" href="/assets/js/109.144984d2.js"><link rel="prefetch" href="/assets/js/11.1f4ed2b0.js"><link rel="prefetch" href="/assets/js/110.393075aa.js"><link rel="prefetch" href="/assets/js/111.8e2be411.js"><link rel="prefetch" href="/assets/js/112.f5db1301.js"><link rel="prefetch" href="/assets/js/113.c5a49956.js"><link rel="prefetch" href="/assets/js/114.f7400c29.js"><link rel="prefetch" href="/assets/js/115.0d4d9691.js"><link rel="prefetch" href="/assets/js/116.5e2d0bba.js"><link rel="prefetch" href="/assets/js/117.b9b6cd5c.js"><link rel="prefetch" href="/assets/js/118.cfffe6ca.js"><link rel="prefetch" href="/assets/js/119.faeb006b.js"><link rel="prefetch" href="/assets/js/12.c55c2945.js"><link rel="prefetch" href="/assets/js/120.2c87041a.js"><link rel="prefetch" href="/assets/js/121.6d6d525b.js"><link rel="prefetch" href="/assets/js/122.a378a709.js"><link rel="prefetch" href="/assets/js/123.8a44d7e0.js"><link rel="prefetch" href="/assets/js/124.eef03f70.js"><link rel="prefetch" href="/assets/js/126.02bdd70b.js"><link rel="prefetch" href="/assets/js/127.6aaf85c7.js"><link rel="prefetch" href="/assets/js/128.2f2f6b78.js"><link rel="prefetch" href="/assets/js/129.b1f7d667.js"><link rel="prefetch" href="/assets/js/13.b5382928.js"><link rel="prefetch" href="/assets/js/130.aadb5b72.js"><link rel="prefetch" href="/assets/js/131.0a0ad3b4.js"><link rel="prefetch" href="/assets/js/132.a05a0c00.js"><link rel="prefetch" href="/assets/js/133.584b8785.js"><link rel="prefetch" href="/assets/js/134.ab61764f.js"><link rel="prefetch" href="/assets/js/135.ccae4853.js"><link rel="prefetch" href="/assets/js/136.38fdaa61.js"><link rel="prefetch" href="/assets/js/137.502d74c0.js"><link rel="prefetch" href="/assets/js/138.12a12ee7.js"><link rel="prefetch" href="/assets/js/139.5ed042c0.js"><link rel="prefetch" href="/assets/js/14.9bf49d25.js"><link rel="prefetch" href="/assets/js/140.32ffb0bc.js"><link rel="prefetch" href="/assets/js/141.3b99bc3f.js"><link rel="prefetch" href="/assets/js/142.afd3e1e7.js"><link rel="prefetch" href="/assets/js/143.ad7b5934.js"><link rel="prefetch" href="/assets/js/144.7bdbdbd9.js"><link rel="prefetch" href="/assets/js/145.3f68756b.js"><link rel="prefetch" href="/assets/js/146.a48f80c3.js"><link rel="prefetch" href="/assets/js/147.eb3a30a3.js"><link rel="prefetch" href="/assets/js/148.563f4279.js"><link rel="prefetch" href="/assets/js/149.7627333e.js"><link rel="prefetch" href="/assets/js/15.47e2fe44.js"><link rel="prefetch" href="/assets/js/150.7cf4b6fd.js"><link rel="prefetch" href="/assets/js/151.200e2d36.js"><link rel="prefetch" href="/assets/js/152.68d5a6f8.js"><link rel="prefetch" href="/assets/js/153.4019d1b1.js"><link rel="prefetch" href="/assets/js/154.7c56b873.js"><link rel="prefetch" href="/assets/js/155.8a895428.js"><link rel="prefetch" href="/assets/js/156.9a106f9c.js"><link rel="prefetch" href="/assets/js/157.b585e3f5.js"><link rel="prefetch" href="/assets/js/158.a9ffbcc1.js"><link rel="prefetch" href="/assets/js/159.9bd41101.js"><link rel="prefetch" href="/assets/js/16.709e62a0.js"><link rel="prefetch" href="/assets/js/17.b149e3eb.js"><link rel="prefetch" href="/assets/js/18.5b57a250.js"><link rel="prefetch" href="/assets/js/19.d2aedd09.js"><link rel="prefetch" href="/assets/js/20.13fd637f.js"><link rel="prefetch" href="/assets/js/21.91dc71fa.js"><link rel="prefetch" href="/assets/js/22.b44ebaaf.js"><link rel="prefetch" href="/assets/js/23.85274bf7.js"><link rel="prefetch" href="/assets/js/24.fdcf9dad.js"><link rel="prefetch" href="/assets/js/25.d7834455.js"><link rel="prefetch" href="/assets/js/26.149bb0bb.js"><link rel="prefetch" href="/assets/js/27.fe47c303.js"><link rel="prefetch" href="/assets/js/28.106a053b.js"><link rel="prefetch" href="/assets/js/29.5cbd445a.js"><link rel="prefetch" href="/assets/js/30.bc8be6db.js"><link rel="prefetch" href="/assets/js/31.776bb22e.js"><link rel="prefetch" href="/assets/js/32.38f1617c.js"><link rel="prefetch" href="/assets/js/33.764d5e8e.js"><link rel="prefetch" href="/assets/js/34.ee4b3664.js"><link rel="prefetch" href="/assets/js/35.0c8a4552.js"><link rel="prefetch" href="/assets/js/36.3114f265.js"><link rel="prefetch" href="/assets/js/37.6623c809.js"><link rel="prefetch" href="/assets/js/38.47b2ae3c.js"><link rel="prefetch" href="/assets/js/39.66477360.js"><link rel="prefetch" href="/assets/js/4.7bd8ec5a.js"><link rel="prefetch" href="/assets/js/40.3c1369b3.js"><link rel="prefetch" href="/assets/js/41.ba422769.js"><link rel="prefetch" href="/assets/js/42.d8feaaee.js"><link rel="prefetch" href="/assets/js/43.7a023784.js"><link rel="prefetch" href="/assets/js/44.578065d4.js"><link rel="prefetch" href="/assets/js/45.599d10a9.js"><link rel="prefetch" href="/assets/js/46.68c58a57.js"><link rel="prefetch" href="/assets/js/47.a0e48134.js"><link rel="prefetch" href="/assets/js/48.a8edc4f3.js"><link rel="prefetch" href="/assets/js/49.a98d9884.js"><link rel="prefetch" href="/assets/js/5.bc317ee9.js"><link rel="prefetch" href="/assets/js/50.7001c5b8.js"><link rel="prefetch" href="/assets/js/51.43d17700.js"><link rel="prefetch" href="/assets/js/52.9ad031a9.js"><link rel="prefetch" href="/assets/js/53.8347b740.js"><link rel="prefetch" href="/assets/js/54.73a1db12.js"><link rel="prefetch" href="/assets/js/55.06ac4334.js"><link rel="prefetch" href="/assets/js/56.caf42a7a.js"><link rel="prefetch" href="/assets/js/57.c8af04ff.js"><link rel="prefetch" href="/assets/js/58.259c0df6.js"><link rel="prefetch" href="/assets/js/59.4a73da6e.js"><link rel="prefetch" href="/assets/js/6.da0024ba.js"><link rel="prefetch" href="/assets/js/60.c88072d5.js"><link rel="prefetch" href="/assets/js/61.a3a06ae4.js"><link rel="prefetch" href="/assets/js/62.e5adc7b0.js"><link rel="prefetch" href="/assets/js/63.48cc1305.js"><link rel="prefetch" href="/assets/js/64.86f8647c.js"><link rel="prefetch" href="/assets/js/65.005e380e.js"><link rel="prefetch" href="/assets/js/66.67bff065.js"><link rel="prefetch" href="/assets/js/67.e12b4c13.js"><link rel="prefetch" href="/assets/js/68.0161e8c6.js"><link rel="prefetch" href="/assets/js/69.5aaf7b82.js"><link rel="prefetch" href="/assets/js/7.1d00dc1d.js"><link rel="prefetch" href="/assets/js/70.6a645155.js"><link rel="prefetch" href="/assets/js/71.001a3225.js"><link rel="prefetch" href="/assets/js/72.2850a293.js"><link rel="prefetch" href="/assets/js/73.d250e0c6.js"><link rel="prefetch" href="/assets/js/74.dafa5bc3.js"><link rel="prefetch" href="/assets/js/75.22c6b92e.js"><link rel="prefetch" href="/assets/js/76.24bc0a51.js"><link rel="prefetch" href="/assets/js/77.e38213b8.js"><link rel="prefetch" href="/assets/js/78.a22de10e.js"><link rel="prefetch" href="/assets/js/79.b0e7fed2.js"><link rel="prefetch" href="/assets/js/8.b16448cb.js"><link rel="prefetch" href="/assets/js/80.67472401.js"><link rel="prefetch" href="/assets/js/81.1df69f3e.js"><link rel="prefetch" href="/assets/js/82.022c9317.js"><link rel="prefetch" href="/assets/js/83.8894e626.js"><link rel="prefetch" href="/assets/js/84.e9f038d8.js"><link rel="prefetch" href="/assets/js/85.ff3971f7.js"><link rel="prefetch" href="/assets/js/86.24e53411.js"><link rel="prefetch" href="/assets/js/87.95b56dc2.js"><link rel="prefetch" href="/assets/js/88.4557cc7d.js"><link rel="prefetch" href="/assets/js/89.1337890b.js"><link rel="prefetch" href="/assets/js/9.1b8d4154.js"><link rel="prefetch" href="/assets/js/90.29d24983.js"><link rel="prefetch" href="/assets/js/91.84b2e3eb.js"><link rel="prefetch" href="/assets/js/92.23e2abeb.js"><link rel="prefetch" href="/assets/js/93.162e9b76.js"><link rel="prefetch" href="/assets/js/94.9ada79ba.js"><link rel="prefetch" href="/assets/js/95.5cc24e13.js"><link rel="prefetch" href="/assets/js/96.0ee67f9e.js"><link rel="prefetch" href="/assets/js/97.9f98bf38.js"><link rel="prefetch" href="/assets/js/98.58600000.js"><link rel="prefetch" href="/assets/js/99.f8a36889.js">
    <link rel="stylesheet" href="/assets/css/0.styles.59ed400b.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/恶魔.webp" alt="凉冰的手记" class="logo"> <span class="site-name can-hide">凉冰的手记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">主页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="后端" class="dropdown-title"><a href="/Java-C/" class="link-title">后端</a> <span class="title" style="display:none;">后端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/back/java/" class="nav-link">Java</a></li><li class="dropdown-item"><!----> <a href="/back/javaWeb/" class="nav-link">JavaWeb</a></li><li class="dropdown-item"><!----> <a href="/back/sql/" class="nav-link">数据库</a></li><li class="dropdown-item"><!----> <a href="/back/SSM/" class="nav-link">SSM</a></li><li class="dropdown-item"><!----> <a href="/back/SpringBoot/" class="nav-link">SpringBoot</a></li><li class="dropdown-item"><!----> <a href="/back/Microservice/" class="nav-link">微服务</a></li></ul></div></div><div class="nav-item"><a href="/Algorithm/" class="nav-link">算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><a href="/technology/" class="link-title">技术</a> <span class="title" style="display:none;">技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/technology/Git/" class="nav-link">Git</a></li><li class="dropdown-item"><!----> <a href="/technology/Linux/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/pages/b5d182/" class="nav-link">正则表达式</a></li></ul></div></div><div class="nav-item"><a href="/pages/edb686/" class="nav-link">面试</a></div><div class="nav-item"><a href="/pages/2aa63b/" class="nav-link">项目记录</a></div><div class="nav-item"><a href="/pages/1b70fb/" class="nav-link">DOA</a></div><div class="nav-item"><a href="/pages/d591da/" class="nav-link">精彩瞬间</a></div><div class="nav-item"><a href="/pages/961a83/" class="nav-link">任意门</a></div><div class="nav-item"><a href="https://github.com/diana-devil/diana-devil.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/devil.jpg"> <div class="blogger-info"><h3>凉冰</h3> <span>奋勇向前的可爱小恶魔！</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">主页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="后端" class="dropdown-title"><a href="/Java-C/" class="link-title">后端</a> <span class="title" style="display:none;">后端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/back/java/" class="nav-link">Java</a></li><li class="dropdown-item"><!----> <a href="/back/javaWeb/" class="nav-link">JavaWeb</a></li><li class="dropdown-item"><!----> <a href="/back/sql/" class="nav-link">数据库</a></li><li class="dropdown-item"><!----> <a href="/back/SSM/" class="nav-link">SSM</a></li><li class="dropdown-item"><!----> <a href="/back/SpringBoot/" class="nav-link">SpringBoot</a></li><li class="dropdown-item"><!----> <a href="/back/Microservice/" class="nav-link">微服务</a></li></ul></div></div><div class="nav-item"><a href="/Algorithm/" class="nav-link">算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><a href="/technology/" class="link-title">技术</a> <span class="title" style="display:none;">技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/technology/Git/" class="nav-link">Git</a></li><li class="dropdown-item"><!----> <a href="/technology/Linux/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/pages/b5d182/" class="nav-link">正则表达式</a></li></ul></div></div><div class="nav-item"><a href="/pages/edb686/" class="nav-link">面试</a></div><div class="nav-item"><a href="/pages/2aa63b/" class="nav-link">项目记录</a></div><div class="nav-item"><a href="/pages/1b70fb/" class="nav-link">DOA</a></div><div class="nav-item"><a href="/pages/d591da/" class="nav-link">精彩瞬间</a></div><div class="nav-item"><a href="/pages/961a83/" class="nav-link">任意门</a></div><div class="nav-item"><a href="https://github.com/diana-devil/diana-devil.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>算法基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数组</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>链表</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>栈</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>队列</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>堆</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>散列表</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>跳表</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>字符串</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/658fbb/" aria-current="page" class="active sidebar-link">字符串</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/658fbb/#bf算法" class="sidebar-link">BF算法</a></li><li class="sidebar-sub-header level2"><a href="/pages/658fbb/#rk算法" class="sidebar-link">RK算法</a></li><li class="sidebar-sub-header level2"><a href="/pages/658fbb/#bm算法" class="sidebar-link">BM算法</a></li><li class="sidebar-sub-header level2"><a href="/pages/658fbb/#kmp算法" class="sidebar-link">KMP算法</a></li><li class="sidebar-sub-header level2"><a href="/pages/658fbb/#trie树" class="sidebar-link">Trie树</a></li><li class="sidebar-sub-header level2"><a href="/pages/658fbb/#ac自动机" class="sidebar-link">AC自动机</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>树</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>图</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>双指针</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>排序</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>二分查找</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>贪心</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>回溯法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>动态规划</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>分治</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/categories/?category=%E7%AE%97%E6%B3%95" title="分类" data-v-06225672>算法</a></li><li data-v-06225672><a href="/categories/?category=%E5%AD%97%E7%AC%A6%E4%B8%B2" title="分类" data-v-06225672>字符串</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/diana-devil" target="_blank" title="作者" class="beLink" data-v-06225672>凉冰</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-06-30</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">字符串<!----></h1> <!----> <div class="theme-vdoing-content content__default"><h2 id="bf算法"><a href="#bf算法" class="header-anchor">#</a> BF算法</h2> <p><strong>暴力匹配算法——朴素匹配算法</strong></p> <ul><li><p>主串与模式串</p> <p><strong>在主串中查找模式串</strong></p> <blockquote><p>​	比方说，<strong>我们在字符串 A 中查找字符串 B，那字符串 A 就是主串，字符串 B 就是模式串。</strong></p> <p>​	我们把主串的长度记作 n，模式串的长度记作 m。因为我们是在主串中查找模式串，所以 n&gt;m。</p></blockquote></li></ul> <img src="/assets/算法/BF算法.webp" style="zoom:50%;"> <ul><li><p>算法优劣</p> <ul><li><p>缺点</p> <blockquote><p>BF 算法的时间复杂度很高，是 O(n*m)</p></blockquote> <p><strong>但在实际的开发中，它却是一个比较常用的字符串匹配算法</strong></p></li> <li><p>优点</p> <blockquote><p>​	第一，实际的软件开发中，**大部分情况下，模式串和主串的长度都不会太长。**而且每次模式串与主串中的子串匹配的时候，当中途遇到不能匹配的字符的时候，就可以就停止了，不需要把 m 个字符都比对一下。所以，尽管理论上的最坏情况时间复杂度是 O(n*m)，但是，统计意义上，大部分情况下，算法执行效率要比这个高很多。</p> <p>​	第二，**朴素字符串匹配算法思想简单，代码实现也非常简单。**简单意味着不容易出错，如果有 bug 也容易暴露和修复。在工程中，在满足性能要求的前提下，简单是首选。</p></blockquote></li></ul></li> <li><p><strong>所以，在实际的软件开发中，绝大部分情况下，朴素的字符串匹配算法就够用了</strong></p></li></ul> <h2 id="rk算法"><a href="#rk算法" class="header-anchor">#</a> RK算法</h2> <p><strong>BF算法的优化版，借助了哈希算法来优化比较</strong></p> <ul><li><p>算法思想</p> <blockquote><p>​	我们通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。</p> <p>​	如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了（这里先不考虑哈希冲突的问题，后面我们会讲到）。因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了。</p></blockquote></li> <li><p>设计哈希算法1</p> <ul><li><p>进制表示法</p> <blockquote><p>​	我们假设要匹配的字符串的字符集中只包含 K 个字符，我们可以用一个 K 进制数来表示一个子串，这个 K 进制数转化成十进制数，作为子串的哈希值。</p> <p>​	使用进制表示法，计算哈希值，不会产生哈希冲突，但是会出现值偏大，大到超出数的范围。</p> <img src="/assets/算法/哈希算法设计.webp" style="zoom:50%;"></blockquote></li> <li><p>哈希值计算规律</p> <blockquote><p>​	相邻子串之间的哈希值的计算公式有一定的关系。</p> <img src="/assets/算法/规律1.webp" style="zoom:50%;"> <img src="/assets/算法/规律2.webp" style="zoom:33%;"> <ul><li><p>计算技巧</p> <p>计算<code>26^(m-1)</code>的时候，可以提前计算好，存入数组中，以下标作为次方数，直接查。</p> <img src="/assets/算法/大数计算技巧.webp" style="zoom:50%;"></li></ul></blockquote></li> <li><p>时间复杂度</p> <blockquote><p>​	整个 RK 算法包含两部分，计算子串哈希值和模式串哈希值与子串哈希值之间的比较。</p> <p>​	第一部分，我们前面也分析了，可以通过设计特殊的哈希算法，只需要扫描一遍主串就能计算出所有子串的哈希值了，所以这部分的时间复杂度是 O(n)。</p> <p>​	模式串哈希值与每个子串哈希值之间的比较的时间复杂度是 O(1)，总共需要比较 n-m+1 个子串的哈希值。所以，这部分的时间复杂度也是 O(n)。</p> <p>​	<strong>所以，RK 算法整体的时间复杂度就是 O(n)。</strong></p></blockquote></li></ul></li> <li><p>设计哈希算法2</p> <blockquote><p>哈希算法的设计方法有很多，我举一个例子说明一下。</p> <p>​	假设字符串中只包含 a～z 这 26 个英文字母，那我们每个字母对应一个数字，比如 a 对应 1，b 对应 2，以此类推，z 对应 26。我们可以把字符串中每个字母对应的数字相加，最后得到的和作为哈希值。这种哈希算法产生的哈希值的数据范围就相对要小很多了。</p></blockquote> <ul><li><p><strong>应对哈希冲突</strong></p> <blockquote><p>​	之前我们只需要比较一下模式串和子串的哈希值，如果两个值相等，那这个子串就一定可以匹配模式串。但是，当存在哈希冲突的时候，有可能存在这样的情况，子串和模式串的哈希值虽然是相同的，但是两者本身并不匹配。</p> <p>​	**当我们发现一个子串的哈希值跟模式串的哈希值相等的时候，我们只需要再对比一下子串和模式串本身就好了。**当然，如果子串的哈希值与模式串的哈希值不相等，那对应的子串和模式串肯定也是不匹配的，就不需要比对子串和模式串本身了。</p></blockquote></li></ul></li> <li><p>RK算法改进</p> <blockquote><p>​     改进一：先计算模式串的hash值，记录下来，然后计算每一个子串的hash，计算一次，就对比一次，如果hash值匹配，在全量对比字符串。这样做可以不用关心hash冲突问题。<strong>不用事先计算出主串中所有子串的哈希值，计算一次，与模式串比较一次即可。</strong></p> <p>​      改进二：计算子串hash值的时候只要计算到（n-m）处即可，剩下的子串长度小于模式串，不用计算.</p></blockquote></li></ul> <h2 id="bm算法"><a href="#bm算法" class="header-anchor">#</a> BM算法</h2> <ul><li><p>核心思想</p> <blockquote><p>​	BM 算法核心思想是，利用模式串本身的特点，在模式串中某个字符与主串不能匹配的时候，<strong>将模式串往后多滑动几位</strong>，以此来减少不必要的字符比较，提高匹配的效率。</p> <img src="/assets/算法/BM算法核心思想.webp" style="zoom:50%;"></blockquote></li> <li><p>原理分析</p> <p><strong>BM算法的匹配顺序是==按照模式串下标从大到小的顺序，倒着匹配的==</strong></p> <ul><li><p>坏字符规则</p> <p><strong>从模式串的末尾往前倒着匹配，当发现某个字符没法匹配的时候，我们把这个没有匹配的字符叫作坏字符（主串中的字符）。</strong></p> <blockquote><p>​	我们拿坏字符 c 在模式串中查找，发现模式串中并不存在这个字符，也就是说，字符 c 与模式串中的任何字符都不可能匹配。<strong>这个时候，我们可以将模式串直接往后滑动三位(模式串的长度=2-(-1)=3)</strong>，将模式串滑动到 c 后面的位置，再从模式串的末尾字符开始比较。</p> <img src="/assets/算法/坏字符规则.webp" style="zoom:50%;"></blockquote> <ul><li><p>移动次数</p> <blockquote><ol><li><p>当发生不匹配的时候，我们把<strong>坏字符==对应==的模式串中的字符下标记作 <code>si</code></strong></p></li> <li><p>如果坏字符在模式串中存在，我们把这个<strong>坏字符在模式串中的下标记作<code>xi</code></strong>。如果不存在，我们把 xi 记作 -1。</p></li> <li><p>那模式串往后移动的位数就等于 <code>si-xi</code>。</p></li> <li><p>如果坏字符在模式串里<strong>多处出现</strong>，那我们在计算 xi 的时候，<strong>选择最靠后的那个</strong>，因为这样不会让模式串滑动过多，导致本来可能匹配的情况被滑动略过。</p> <img src="/assets/算法/坏字符移动次数.webp" style="zoom:67%;"></li></ol></blockquote></li> <li><p>优缺点</p> <ul><li><p>优点</p> <blockquote><p>BM 算法在最好情况下的时间复杂度非常低，是 O(n/m)</p> <p>匹配具有类似特点的模式串和主串的时候，BM 算法非常高效。</p></blockquote></li> <li><p>缺点</p> <blockquote><p>根据 si-xi 计算出来的移动位数，有可能是==负数==</p> <p>比如主串是 aaaaaaaaaaaaaaaa，模式串是 baaa。不但不会向后滑动模式串，还有可能倒退。</p> <p>所以，BM 算法还需要用到“好后缀规则”。</p></blockquote></li></ul></li></ul></li> <li><p>好后缀规则</p> <p><strong>在从后往前匹配的时候，已经匹配到的字符串称为好后缀。</strong></p> <img src="/assets/算法/好后缀.webp" style="zoom:67%;"> <ul><li><p>滑动次数</p> <blockquote><p>​	在<strong>好后缀的后缀子串</strong>中，查找最长的、能跟模式串<strong>前缀子串</strong>匹配的后缀子串；</p> <p>简单来说，就是不要一下子移动一整个模式串的距离，<strong>看看模式串的开头部分和好后缀的结尾部分有没有重和的</strong>，有重和的就少移动几位。</p> <p><code>{u}</code>为好后缀，<code>{v}</code>为能够匹配上的模式串的前缀子串</p> <p><strong>滑动次数=模式串长度-{v}的长度</strong></p> <img src="/assets/算法/好后缀移动次数.webp" style="zoom:50%;"></blockquote></li></ul></li> <li><p>方法选用</p> <blockquote><p>​       我们可以分别计算好后缀和坏字符往后滑动的位数，<strong>然后取两个数中最大的，作为模式串往后滑动的位数</strong>。这种处理方法还可以避免我们前面提到的，根据坏字符规则，计算得到的往后滑动的位数，有可能是负数的情况。</p></blockquote></li></ul></li> <li><p>算法实现</p> <ul><li><p>坏字符规则</p> <blockquote><ol><li>可以预先将模式串中的每个字符及其下标都存储到散列表中。</li> <li>计算下标<code>xi</code>的时候，可以直接查表获取，而不用遍历整个字符串。</li></ol></blockquote> <ul><li><p>提供一种散列表的方法</p> <blockquote><p>使用数组，将模式串单个字符的ascii码值作为数组下标，数组中的值为该字符在模式串中的下标。</p></blockquote></li> <li><p>移动次数</p></li> <li><p><code>bc</code>为散列表数组，<code>i</code>为主串的循环大变量，<code>j</code>为模式串的循环小变量</p> <img src="/assets/算法/坏字符实现.webp" style="zoom:50%;"></li></ul></li> <li><p>好后缀规则</p> <ul><li><p>核心内容</p> <ul><li><p>在模式串中，查找跟好后缀匹配的另一个子串；</p></li> <li><p>在好后缀的后缀子串中，查找最长的、能跟模式串前缀子串匹配的后缀子串；</p></li></ul></li> <li><p>实现方法1</p> <p><strong>对模式串进行预处理</strong>,解决第一个核心内容</p> <blockquote><p>​	因为好后缀子串也是模式串的后缀子串，所以我们可以提前将<strong>好后缀子串在模式串中再一次出现的起始下标值</strong>记录下来。</p> <p>将该值用suffix数组存储，下标为后缀子串的长度。</p> <ol><li><p>如果模式串中有多个（大于 1 个）子串跟后缀子串{u}匹配，存储模式串中最靠后的那个子串的起始位置，也就是下标最大的那个子串的起始位置。</p></li> <li><p>如果该后缀没有再次出现，则将其设为<code>-1</code></p></li></ol> <p>比如说，后缀子串为<code>b</code>的时候，<code>b</code>再次出现在下标2处，且自身长度为1，所以<code>suffix[1]=2</code></p> <p>后缀子串为<code>cab</code>的时候，<code>cab</code>再次出现在下标0处，且自身长度为3，所以<code>suffix[3]=0</code></p> <p>后缀子串为<code>bcab</code>的时候，<code>bcab</code>没有再次出现，且自身长度为4，所以<code>suffix[4]=-1</code></p></blockquote></li></ul> <img src="/assets/算法/好后缀实现1.webp" style="zoom:67%;"> <ul><li><p>实现方法2</p> <p>除了 suffix 数组之外，<strong>我们还需要另外一个 boolean 类型的 prefix 数组，来记录模式串的后缀子串是否能匹配模式串的前缀子串。</strong></p> <img src="/assets/算法/好后缀实现2.webp" style="zoom:67%;"> <p>如果suffix数组的值为0，则说明该后缀自串也是模式串的前缀子串，prefix记为true；</p></li> <li><p>移动次数</p> <ul><li><p>好后缀再次出现</p> <img src="/assets/算法/好后缀再次出现.webp" style="zoom:67%;"></li> <li><p>好后缀没有再次出现，但是有好后缀的后缀子串为模式串的前缀子串</p> <img src="/assets/算法/后缀子串与前缀子串匹配.webp" style="zoom:67%;"></li> <li><p>什么都没有</p> <img src="/assets/算法/什么都没有.webp" style="zoom:67%;"></li></ul></li></ul></li></ul></li> <li><p>==优秀思想总结==</p> <p><strong>代码实现具体细节不重要，重要的是处理问题的思想，及更好的优化思路</strong></p> <ul><li>使用散列表提高查找效率</li> <li>对于重复的，较难的计算，预处理好，需要的时候直接查(26^(m-1))</li> <li>善用之前的信息。</li></ul></li></ul> <h2 id="kmp算法"><a href="#kmp算法" class="header-anchor">#</a> KMP算法</h2> <ul><li><p>核心思想</p> <blockquote><p>​	KMP 算法就是在试图寻找一种规律：在模式串和主串匹配的过程中，当遇到坏字符后，对于已经比对过的好前缀，能否找到一种规律，将模式串一次性滑动很多位？</p> <p>​	这里一次性移动了2位，<code>2=主串虚线框中第一个a的下标-子串虚线框中第一个a的下标</code></p> <img src="/assets/算法/KMP算法核心.webp" style="zoom:67%;"></blockquote></li> <li><p>最长可匹配前(后)缀</p> <p>把好前缀的所有后缀子串中，最长的可匹配前缀子串的那个后缀子串，叫作最长可匹配后缀子串；对应的前缀子串，叫作最长可匹配前缀子串。</p> <img src="/assets/算法/最长可匹配子串.webp" style="zoom:67%;"> <p>最长子串的计算只有模式串有关，可以提前计算。用==next数组(前缀表)==表示。</p> <ol><li>数组的下标是每个前缀结尾字符下标</li> <li>数组的值是这个前缀的   最长可以匹配前缀子串   的结尾字符下标。
<ul><li>比如，<code>aba</code>可以匹配到的最长前缀子串为<code>a</code>，其下标为0</li> <li><code>abab</code>可以匹配到的最长前缀子串为<code>ab</code>，其下标为1</li></ul></li> <li>==<strong>前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。</strong>==
<ul><li>==<code>next[i]=x</code>表示，s[0:i]具有长度为x+1的完全相同的前缀和后缀。==</li> <li>从next+1开始匹配,即前一个最长匹配前缀子串末尾的下一位。next中存的是末尾的下标，所有模式串从next+1开始匹配。</li> <li><code>j = next[j - 1] + 1</code></li> <li><img src="/assets/%E7%AE%97%E6%B3%95/KMP%E7%B2%BE%E8%AE%B21.gif" alt=""></li></ul></li></ol> <img src="/assets/算法/next字符串.webp" style="zoom:67%;"></li> <li><p>KMP算法代码</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// a, b分别是主串和模式串；n, m分别是主串和模式串的长度。</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">kmp</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> next <span class="token operator">=</span> <span class="token function">getNexts</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 一直找到a[i]和b[j]</span>
            j <span class="token operator">=</span> next<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//j为一次移动的次数，对于模式串来说，不用从0开始比了，一下子滑动到j处</span>
        <span class="token comment">//进入循环的j为坏字符的下标</span>
        <span class="token comment">//进入后更新j为最长匹配前缀的末尾字符串的下一位，即next[j-1]+1</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token operator">++</span>j<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 找到匹配模式串的了</span>
            <span class="token keyword">return</span> i <span class="token operator">-</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>next数组计算方法</p> <ul><li><p>思想</p> <p><strong>在计算next[i]的时候，利用前面已经计算出的next[0],……next[i-1]。</strong></p> <ul><li><p>第一种情况（加字符相等）</p> <blockquote><p>如在计算上文的next[3]和next[4]那样.以next[3]为例</p> <p>next[2]时,整个串为<code>aba</code>,最长前缀子串为<code>a</code>,这个a是下标为0的a，<code>k=0,i=2,next[i]=k==&gt;next[2]=0</code></p> <p>在计算next[3]时，整个串变为<code>abab</code>,新添加的这个b(下标为3)，刚好等于next[0]时的最长前缀子串的下一个字符<code>b</code>(下标为1)</p> <p>此时，next[3]的最长前缀子串为<code>ab</code>，所以next[1]=next[0]+1=1,<code>k=1,i=3,next[i]=k==&gt;next[3]=1</code></p></blockquote></li> <li><p>==第二种情况(加字符不等)==</p> <blockquote><p>设字符串为<code>abxabcabxabx</code>,共12位，下标从0到11</p> <p>​	在计算next[10]时，串为<code>abxabcabxab</code>,最长前缀子串为<code>abxab</code>,即<code>k=4,i=10,next[10]=4</code></p> <p>​	在计算next[11]时，串为<code>abxabcabxabx</code>,新添加了一个<code>x</code>，而next[10]的最长前缀子串的下一个字符为<code>c</code>，二者不相等，<code>即k=4,i=11,k'=k+1=5,next[5]!=next[11]</code>，则找一个次长前缀子串，即为<code>abxab</code>的的最长前缀子串，即满足情况1的子串。简单来说，我下一个是<code>x</code>，你去找一个最长前缀子串，下一个也是<code>x</code>，符合情况1，这样可以直接用加法来解决。</p> <p>​		<code>k=next[4]=1</code>,此时最长前缀子串为<code>ab</code>，<code>str[k+1]=str[2]====x====str[i]=str[11]</code>,正好满足情况1，此时的最长前缀子串为<code>abx</code>，即<code>next[11]=2</code>。</p></blockquote></li></ul></li> <li><p>代码实现</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// b表示模式串，m表示模式串的长度</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getNexts</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>
    next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//去找满足情况1的子串</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> b<span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            k <span class="token operator">=</span> next<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//回溯</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//找到了，++</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token operator">++</span>k<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//赋值</span>
        next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul></li> <li><p>复杂度分析</p> <ul><li>空间复杂度——next数组，O(n)</li> <li>时间复杂度
<ul><li>求next数组——O(m)
<ul><li>就是大循环的次数，小循序次数肯定小于m，设为k，即总体为O(k*m)</li> <li>k相对于m来说，值很小，所以总的时间复杂度为O(m)</li></ul></li> <li>KMP算法——O(n)，同求next数组</li> <li>==总的——O(m+n)==</li></ul></li></ul></li></ul> <h2 id="trie树"><a href="#trie树" class="header-anchor">#</a> Trie树</h2> <p><strong>Trie 树，也叫“字典树”。它是一种专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题。</strong></p> <ul><li><p>核心思想</p> <blockquote><p><strong>Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起。</strong></p></blockquote> <p>例如，我们有 6 个字符串，它们分别是：<code>how，hi，her，hello，so，see</code>。构造Trie树，则如下图所示。从根节点到红色节点的一条路径表示一个字符串（注意：红色节点并不都是叶子节点）——例如<code>hi，hil</code>,<code>i</code>和<code>l</code>两个结点都要标红，而<code>i</code>不是叶子结点。</p> <img src="/assets/算法/构造Trie树.webp" style="zoom:67%;"></li> <li><p>查找</p> <ul><li><p><code>her</code></p> <p>分解为<code>h</code>,<code>e</code>,<code>r</code>最后找到红色结点，说明是一个<strong>完整的字符</strong>。</p> <img src="/assets/算法/查找her.webp" style="zoom:50%;"></li> <li><p><code>he</code></p> <p>分解为<code>h</code>,<code>e</code>最后没有找到红色结点，说明是一个<strong>完整的字符的字符前缀</strong>。</p> <img src="/assets/算法/查找he.webp" style="zoom:50%;"></li></ul></li> <li><p>Trie树实现</p> <blockquote><p>假设字符串中只有26个小写字符，**则可以用一个大小为26的数组来存储子节点的指针。**不存在子节点的存null</p> <img src="/assets/算法/Trie树实现.webp" style="zoom:50%;"></blockquote> <ul><li><p>数据结构</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">TrieNode</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span> data<span class="token punctuation">;</span>
  <span class="token class-name">TrieNode</span> children<span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>时间复杂度</p> <p>设总的字符串长度为n，要查找的字符串长度为k，则</p> <ul><li>构建Trim树——O(n)</li> <li>构建好树，在树中查字符串——O(k)</li></ul></li></ul></li> <li><p>Trie树优化</p> <ul><li><p>Trie树 很耗内存</p> <p>上述说的，使用数组存子节点指针的方式，需要大量的存储空间，而且很多空间都是闲置的。</p></li> <li><p>改进</p> <ul><li>可以将数组，改成散列表，跳表，红黑树等，稍微牺牲一些查询效率，以节约内存</li> <li>缩点优化——将斜树的内容放到一个结点，例如<code>l</code>,<code>l</code>,<code>o</code>可以存储在一起，<code>llo</code>，不影响查询</li></ul></li></ul></li> <li><p>Trie树与散列表、红黑树的比较</p> <ul><li><p>查找定长的字符串</p> <blockquote><p>在一组字符串中，查找一个固定的字符串，<strong>Trie树虽然效率很高，但是有很多缺点</strong></p> <ol><li>第一，字符串中包含的字符集不能太大。我们前面讲到，如果字符集太大，那存储空间可能就会浪费很多。即便可以优化，但也要付出牺牲查询、插入效率的代价。</li> <li>第二，要求字符串的前缀重合比较多，不然空间消耗会变大很多。</li> <li>第三，如果要用 Trie 树解决问题，那我们就要自己从零开始实现一个 Trie 树，还要保证没有 bug，这个在工程上是将简单问题复杂化，除非必须，一般不建议这样做。</li> <li>第四，我们知道，通过指针串起来的数据块是不连续的，而 Trie 树中用到了指针，所以，对缓存并不友好，性能上会打个折扣。</li></ol> <p>综上，查找固定长度的字符串，Trie树不如使用红黑树或者散列表。</p></blockquote></li> <li><p><strong>查找字符串前缀匹配的字符串</strong></p> <blockquote><p>Trie 树最有优势的是查找前缀匹配的字符串。对于这个功能，其他数据结构，爱莫能助</p></blockquote> <ul><li>实现搜索关键词提示功能</li> <li>实现代码(命令)自动补全功能</li></ul></li></ul></li> <li><p>利用Trie树实现搜索关键词提示功能(最基本的功能实现)</p> <p>深入剖析搜索引擎</p> <img src="/assets/算法/搜索关键词.webp" style="zoom:50%;"> <p>假设，词库中有<code>hello</code>,<code>her</code>,<code>hi</code>,<code>how</code>,<code>see</code>,<code>so</code></p> <ul><li>输入<code>h</code>，展示<code>hello</code>,<code>her</code>,<code>hi</code>,<code>how</code></li> <li>输入<code>he</code>，展示<code>hello</code>,<code>her</code></li></ul></li></ul> <h2 id="ac自动机"><a href="#ac自动机" class="header-anchor">#</a> AC自动机</h2> <p><strong>BF 算法、RK 算法、BM 算法、KMP 算法,都是单模式串匹配算法， Trie 树，AC自动机都是多模式串匹配算法。</strong></p> <p>AC 自动机是基于 Trie 树的一种改进算法，它跟 Trie 树的关系，就像单模式串中，KMP 算法与 BF 算法的关系一样。</p> <ul><li><p>利用Tire树实现多模式串匹配</p> <p><strong>前面Trie那节介绍的是匹配一个固定长度的字符串问题，很短小，就一个主串匹配一个模式串</strong></p> <ul><li><p>多模式串匹配</p> <blockquote><p>​	多模式串匹配算法，就是在多个模式串和一个主串之间做匹配，也就是说，在一个主串中查找多个模式串。</p></blockquote></li> <li><p>实现流程——借助上图的trie树</p> <blockquote><p>​	设有超长字符串，作为主串（cheisesa），从第一个字符（c）开始，在 Trie 树中匹配。当匹配到 Trie 树的叶子节点，或者中途遇到不匹配字符的时候，我们将主串的开始匹配位置后移一位，也就是从字符h开始，重新在 Trie 树中匹配(<strong>重新从根节点开始搜索</strong>)。<code>hei</code>这个字符串可以匹配到，做相应处理。</p> <p>​	然后继续从s开始匹配,<code>se</code>符合，<code>ses</code>不符合。则继续从<code>e</code>开始匹配，重复此过程。</p></blockquote></li> <li><p>缺点</p> <p><strong>每次匹配失败后，从主串当前匹配字符往后移动一位，继续从根节点开始重新匹配，就相当于BF算法在匹配时做法。</strong></p> <blockquote><p>举例：假设匹配abcd</p> <ul><li><p>Trie树</p> <ol><li><p><code>abc</code>没问题,继续匹配，<code>d</code>和<code>e</code>匹配不上</p></li> <li><p>匹配起始结点从<code>a</code>后移一维，重新开始匹配<code>bcd</code>，匹配完成。</p></li> <li><p>分析：<code>b</code>,<code>c</code>进行了重复匹配.在模式串<code>abcd</code>中已经匹配过了<code>bc</code>，在模式串<code>bcd</code>中再次进行了<code>b</code>和<code>c</code>的匹配。</p></li></ol></li> <li><p>AC自动机</p> <ol><li><code>abc</code>没问题,继续匹配，<code>d</code>和<code>e</code>匹配不上</li> <li>通过c的失败指针指向模式串<code>bcd</code>的<code>c</code>，这个<code>d</code>刚好可以和<code>abcd</code>中<code>d</code>匹配上，如果到了结尾，可以直接输出匹配到了<code>bcd</code></li> <li>分析:在模式串<code>abcd</code>中已经匹配过了<code>bc</code>，在模式串<code>bcd</code>中只匹配了<code>d</code></li></ol></li></ul> <img src="/assets/算法/同加不等.webp" style="zoom:50%;"></blockquote></li></ul></li> <li><p>AC自动机核心思想</p> <blockquote><p>AC 自动机实际上就是在 Trie 树之上，加了类似 KMP 的 next 数组，只不过此处的 next 数组是构建在树上罢了。</p></blockquote> <ul><li><p>数据结构</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AcNode</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">char</span> data<span class="token punctuation">;</span> 
    <span class="token keyword">public</span> <span class="token class-name">AcNode</span><span class="token punctuation">[</span><span class="token punctuation">]</span> children <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AcNode</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 字符集只包含a~z这26个字符</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> isEndingChar <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 结尾字符为true</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> length <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 当isEndingChar=true时，记录模式串长度</span>
    <span class="token keyword">public</span> <span class="token class-name">AcNode</span> fail<span class="token punctuation">;</span> <span class="token comment">// 失败指针</span>
    <span class="token keyword">public</span> <span class="token class-name">AcNode</span><span class="token punctuation">(</span><span class="token keyword">char</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p><strong>AC自动机的构建</strong></p> <ul><li>将多个模式串构建成 Trie 树；构建一个敏感词的Trie树。——详见Trie树</li> <li>在 Trie 树上构建失败指针（相当于 KMP 中的失效函数 next 数组）。</li></ul></li></ul></li> <li><p>构建失败指针</p> <p><strong>核心思想就跟构造KMP的next数组一样</strong></p> <ul><li><p>初始构建失败指针</p> <blockquote><p>​	假设，我们要匹配的主串为abcd，模式串分别是 c，bc，bcd，abcd；</p> <p>​	我们沿 Trie 树走到 p 节点，也就是下图中的紫色节点，那 p 的失败指针就是从 root 走到紫色节点形成的字符串 abc的末尾<code>c</code>，指向跟<strong>所有模式串前缀匹配的最长可匹配后缀子串</strong>，就是箭头指的 bc 模式串的<code>c</code>。</p> <img src="/assets/算法/AC自动机1.webp" style="zoom:50%;"> <p>​	如果我们把树中相同深度的节点放到同一层，那么某个节点的失败指针只有可能出现在它所在层的<strong>上层</strong>。</p></blockquote> <ul><li><p>可匹配后缀子串</p> <blockquote><p>​	字符串 abc 的后缀子串有两个 bc，c，我们拿它们与其他模式串匹配，如果某个后缀子串可以匹配某个模式串的前缀，那我们就把这个后缀子串叫作可匹配后缀子串。</p></blockquote></li></ul></li> <li><p>构建子节点失败指针</p> <p>我们假设节点 p 的失败指针指向节点 q，<strong>我们看节点 p 的子节点 pc 对应的字符，是否也可以在节点 q 的子节点中找到。</strong></p> <ul><li><p>同加相等====第一种情况</p> <blockquote><p>​	如果找到了节点 q 的一个子节点 qc，对应的字符跟节点 pc 对应的字符<strong>相同</strong>，则将节点 pc 的失败指针指向节点 qc。</p> <img src="/assets/算法/同加相等.webp" style="zoom:50%;"></blockquote></li> <li><p>同加不等====第二种情况</p> <blockquote><p>​	如果节点 q 中没有子节点的字符等于节点 pc 包含的字符，则令 <strong>q=q-&gt;fail</strong>（fail 表示失败指针，这里有没有很像 KMP 算法里求 next 的过程？k=next[k]），继续上面的查找，直到 q 是 root 为止，如果还没有找到相同字符的子节点，就让节点 pc 的失败指针指向 root。</p> <img src="/assets/算法/同加不等.webp" style="zoom:50%;"></blockquote></li></ul></li> <li><p>完整的AC自动机构建</p> <img src="/assets/算法/完整的AC自动机构建.webp" style="zoom:67%;"></li></ul></li> <li><p>如何在AC自动机上匹配主串</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">match</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> text<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// text是主串</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> text<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token class-name">AcNode</span> p <span class="token operator">=</span> root<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> idx <span class="token operator">=</span> text<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span>
        <span class="token comment">//前面的条件是，在匹配模式串时，当前模式串的没有text[i]这个字符，即数组部分存储null指针。</span>
        <span class="token comment">//一直找到有text[i]这个字符的模式串，由于是通过失败指针跳跃的，</span>
        <span class="token comment">//所以该模式串前面虽然没有匹配过,但是重新匹配的话肯定能匹配上，换而言之就是，它的前面的字符串肯定在主串中出现过，且在其他模式串中匹配过。</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> p <span class="token operator">!=</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            p <span class="token operator">=</span> p<span class="token punctuation">.</span>fail<span class="token punctuation">;</span> <span class="token comment">// 失败指针发挥作用的地方</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//找到了有text[i]这个字符模式串</span>
        p <span class="token operator">=</span> p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> p <span class="token operator">=</span> root<span class="token punctuation">;</span> <span class="token comment">// 如果没有匹配的，从root开始重新匹配</span>
        
        <span class="token class-name">AcNode</span> tmp <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>tmp <span class="token operator">!=</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 打印出可以匹配的模式串</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">.</span>isEndingChar <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">int</span> pos <span class="token operator">=</span> i<span class="token operator">-</span>tmp<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;匹配起始下标&quot;</span> <span class="token operator">+</span> pos <span class="token operator">+</span> <span class="token string">&quot;; 长度&quot;</span> <span class="token operator">+</span> tmp<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            tmp <span class="token operator">=</span> tmp<span class="token punctuation">.</span>fail<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>性能分析——<code>不准</code></p> <p>设总的字符串(所有模式串的长度总和)长度为n，要查找的字符串(主串)长度为k，则</p> <ul><li>构建AC自动机
<ul><li>构建Trie树——O(n)</li> <li>构建失败指针——O(n)</li></ul></li> <li>匹配主串——O(k)</li></ul></li></ul></div></div> <!----> <div class="page-edit"><!----> <div class="tags"><a href="/tags/?tag=%E7%9F%A5%E8%AF%86" title="标签">#知识</a><a href="/tags/?tag=%E7%AE%97%E6%B3%95" title="标签">#算法</a></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2023 07 3</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/e28ee4/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">跳表</div></a> <a href="/pages/4d7338/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">二叉树</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/e28ee4/" class="prev">跳表</a></span> <span class="next"><a href="/pages/4d7338/">二叉树</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/0446de/"><div>
            数据层解决方案
            <!----></div></a> <span class="date">07-03</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/e76fff/"><div>
            第三方技术整合
            <!----></div></a> <span class="date">07-03</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/cd183e/"><div>
            原理篇
            <!----></div></a> <span class="date">07-03</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:1693849288@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/diana-devil" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://y.qq.com/n/ryqq/playlist/3202075040" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2023-2023
    <span>by 凉冰 </span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><!----><!----><canvas id="vuepress-canvas-cursor"></canvas><div class="reco-bgm-panel" data-v-b1d3339e><audio id="bgm" src="/bgm/G_E_M_ 邓紫棋 - FIND YOU.ogg" data-v-b1d3339e></audio> <div class="reco-float-box" style="bottom:200px;z-index:999999;display:none;" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><img src="/bgm/GEM.jpg" data-v-b1d3339e></div> <div class="reco-bgm-box" style="left:10px;bottom:10px;z-index:999999;" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><div class="reco-bgm-cover" style="background-image:url(/bgm/GEM.jpg);" data-v-b1d3339e><div class="mini-operation" style="display:none;" data-v-b1d3339e><i class="reco-bgm reco-bgm-pause" style="display:none;" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-play" style="display:none;" data-v-b1d3339e></i></div> <div class="falut-message" style="display:none;" data-v-b1d3339e>
          播放失败
        </div></div> <div class="reco-bgm-info" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><div class="info-box" data-v-b1d3339e><i class="reco-bgm reco-bgm-music music" data-v-b1d3339e></i>FIND YOU</div> <div class="info-box" data-v-b1d3339e><i class="reco-bgm reco-bgm-artist" data-v-b1d3339e></i>G_E_M_ 邓紫棋</div> <div class="reco-bgm-progress" data-v-b1d3339e><div class="progress-bar" data-v-b1d3339e><div class="bar" data-v-b1d3339e></div></div></div> <div class="reco-bgm-operation" data-v-b1d3339e><i class="reco-bgm reco-bgm-last last" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-pause pause" style="display:none;" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-play play" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-next next" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-volume1 volume" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-mute mute" style="display:none;" data-v-b1d3339e></i> <div class="volume-bar" data-v-b1d3339e><div class="bar" data-v-b1d3339e></div></div></div></div> <div class="reco-bgm-left-box" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><i class="reco-bgm reco-bgm-left" data-v-b1d3339e></i></div></div></div></div></div>
    <script src="/assets/js/app.3ee2b30c.js" defer></script><script src="/assets/js/2.fc657b59.js" defer></script><script src="/assets/js/125.20627b3b.js" defer></script><script src="/assets/js/3.e0ec9727.js" defer></script>
  </body>
</html>
